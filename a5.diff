diff --git a/a5.diff b/a5.diff
new file mode 100644
index 0000000..8ec9fd0
--- /dev/null
+++ b/a5.diff
@@ -0,0 +1,4578 @@
+diff --git a/log.txt b/log.txt
+new file mode 100644
+index 0000000..30dc9ff
+--- /dev/null
++++ b/log.txt
+@@ -0,0 +1,210 @@
++commit a3639fee4759e5f7e9e02b6acfeaceaf339ce13d
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 23:11:44 2022 -0500
++
++    removed more useless import statements
++
++commit 33761923ef5194d3ee197ee6ac648df8467b61a5
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 23:08:42 2022 -0500
++
++    change import statements
++
++commit 375810dee047be9921e09812fd5d18718561d31a
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 23:06:33 2022 -0500
++
++    removed file for submission
++
++commit 12947c04e23eb41bf513b71a8e00d3e66e3d60ab
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 23:04:42 2022 -0500
++
++    fixed ParseAndMutateApp
++
++commit 9c984d9d8e828128fe6dc8e563e1cbbc15d81753
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 16:28:39 2022 -0500
++
++    idk
++
++commit f4e097820cb57974ced4434a0f43ead5535aeef8
++Merge: 2dc1764 351675e
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 16:10:40 2022 -0500
++
++    fix merge conflict
++
++commit 2dc17640bd28b83f879ded202e3ea3d1833a3f5e
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 16:07:20 2022 -0500
++
++    idk
++
++commit 351675e9d2d653626f446257fd44fad389377e91
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Tue Nov 8 15:47:57 2022 -0500
++
++    Everything written
++
++commit 83ca663bc280bc153452864536abe2bdb44a46e2
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 13:14:31 2022 -0500
++
++    tested mutations
++
++commit 29017a9ba1aba3e6028a774bc837d2de092b3a6b
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Tue Nov 8 02:02:23 2022 -0500
++
++    testing mutations
++
++commit 84273be81299ddc221d2384f2311628f5197d529
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Tue Nov 8 00:30:30 2022 -0500
++
++    Errors Fixed
++
++commit 72e22a60bdec94169c2d19e2e80ea1ccaf93c69a
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Mon Nov 7 22:32:55 2022 -0500
++
++    testing remove mutation
++
++commit ec17983630e1fc26725ce410bb84b175432803b1
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Mon Nov 7 19:22:42 2022 -0500
++
++    fixed prettyPrint() for BinaryOp
++
++commit 535162ab6f358c4edcb01b0daa61955de96976a4
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Mon Nov 7 13:44:18 2022 -0500
++
++    Finished Pretty Printing
++
++commit fe7a9af4e23ae290db16faf6d11c4f67ac7d68b0
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Mon Nov 7 12:17:53 2022 -0500
++
++    PrettyPrint
++
++commit ad20c573f71516a718ab407367633db17a4dcc91
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Sun Nov 6 23:53:19 2022 -0500
++
++    finished mutations hopefully
++
++commit 5f32bfa39b7a64a74decc1314b69a4008e947826
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Sun Nov 6 18:34:47 2022 -0500
++
++    implemented more mutations
++
++commit 651c464d878f423a20f384486c76a5fc59b30598
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Sun Nov 6 01:09:59 2022 -0500
++
++    I broke my damn phone
++
++commit e45d1eadadc32f7aea94e402a80155837c5afb73
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Sun Nov 6 00:10:58 2022 -0400
++
++    changed remove mutation for negative expr
++
++commit 219dda15e0771c49df2b3d859fcf3cba2f6debe0
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Sun Nov 6 00:07:17 2022 -0400
++
++    fixed clone() in mem
++
++commit 5534bf3ff1a5a332b6e543bdce3b241519a6388d
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Sun Nov 6 00:06:16 2022 -0400
++
++    implement swap mutation
++
++commit 2ad437f3ecf2423f9ca6352f3562b74a7045e8d9
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Sat Nov 5 21:44:33 2022 -0400
++
++    tested ParserImpl and implemented Remove
++
++commit d6c8b2f501ffc642bc8153a60140324b37ca38b3
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Fri Nov 4 20:20:16 2022 -0400
++
++    forgot semicolon
++
++commit 99fc466f71236523763bac79bf094f228aae4823
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Fri Nov 4 20:19:39 2022 -0400
++
++    added parent pointers and change structure of mutations
++
++commit aaaf325323391658dd24f4a91f7d3a4af1a664ef
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Fri Nov 4 00:34:15 2022 -0400
++
++    added mutations classes
++
++commit db43745ba215c26a55d45fe36826534b76902be7
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Thu Nov 3 23:47:35 2022 -0400
++
++    added negative node and negative expr
++
++commit bc01048481f1ac8e80edd52e9d1893218dd4fd9c
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Wed Nov 2 22:29:45 2022 -0400
++
++    deleted duplicate class
++
++commit db13b13db5b9d6bc3cb00d4ac9c56dbdcece3d31
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Wed Nov 2 22:28:53 2022 -0400
++
++    finished AST
++
++commit ff3c70ba7617fcb7f5a911494e660fe7b31c6ba5
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Tue Nov 1 00:10:24 2022 -0400
++
++    bruh
++
++commit 362d7d3bbe6d4b4d3b0f5c2ce9cedc134a6b17f4
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Mon Oct 31 22:37:51 2022 -0400
++
++    heehee
++
++commit 26f338ed02aac4baf473205727b174a6886b9963
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Mon Oct 31 17:23:07 2022 -0400
++
++    Commit 1
++
++commit 8f8494028804d2d41b880fd02256e49f9f821090
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Sun Oct 30 21:16:38 2022 -0400
++
++    stuff
++
++commit 09a7fa9992c9dbbcfa4187ff44d644d89f635986
++Author: Richard Lin <rl659@cornell.edu>
++Date:   Wed Oct 26 01:51:24 2022 -0400
++
++    heehee
++
++commit 135253f3566982a3baa190922a359f27b9206f3f
++Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
++Date:   Sun Oct 23 21:47:32 2022 -0400
++
++    Commit 1
++
++commit d04b083ff93ddb3d0f0cfee9b3fbec533328b6f6
++Author: Shiyuan Huang <shiyuancn@live.cn>
++Date:   Mon Oct 17 18:49:43 2022 -0400
++
++    Initial commit
+diff --git a/settings.gradle b/settings.gradle
+index 1385ed8..c816aa6 100644
+--- a/settings.gradle
++++ b/settings.gradle
+@@ -1 +1 @@
+-rootProject.name = 'CHANGE ME'
++rootProject.name = 'Critterworld'
+\ No newline at end of file
+diff --git a/src/main/java/ast/AbstractNode.java b/src/main/java/ast/AbstractNode.java
+index f86b603..68860c2 100644
+--- a/src/main/java/ast/AbstractNode.java
++++ b/src/main/java/ast/AbstractNode.java
+@@ -31,6 +31,7 @@ public abstract class AbstractNode implements Node
+     @Override
+     public Node nodeAt(int index)
+     {
++        if(index < 0 || index >= this.size()) throw new IndexOutOfBoundsException();
+         Queue<Node> queue = new LinkedList<Node>();
+         queue.add(this);
+         int count = 0;
+diff --git a/src/main/java/ast/Action.java b/src/main/java/ast/Action.java
+index 0016c20..5c6f37a 100644
+--- a/src/main/java/ast/Action.java
++++ b/src/main/java/ast/Action.java
+@@ -3,6 +3,8 @@ package ast;
+ import parse.TokenType;
+ 
+ import java.util.ArrayList;
++import java.util.Collection;
++import java.util.Collections;
+ import java.util.List;
+ 
+ public class Action extends AbstractNode
+@@ -48,7 +50,7 @@ public class Action extends AbstractNode
+             list.add(value);
+             return list;
+         }
+-        else return null;
++        else return new ArrayList<>();
+     }
+ 
+     @Override
+@@ -83,7 +85,6 @@ public class Action extends AbstractNode
+ 
+     public void changeExpr(Expr e)
+     {
+-        value.setParent(null);
+         value = e;
+         value.setParent(this);
+     }
+diff --git a/src/main/java/ast/AheadSensor.java b/src/main/java/ast/AheadSensor.java
+index c7aea44..8aca256 100644
+--- a/src/main/java/ast/AheadSensor.java
++++ b/src/main/java/ast/AheadSensor.java
+@@ -21,7 +21,6 @@ public class AheadSensor extends Sensor
+ 
+     public void changeExpr(Expr e)
+     {
+-        this.e.setParent(null);
+         this.e = e;
+         this.e.setParent(this);
+     }
+diff --git a/src/main/java/ast/BinaryCondition.java b/src/main/java/ast/BinaryCondition.java
+index 9862c01..6cbf07c 100644
+--- a/src/main/java/ast/BinaryCondition.java
++++ b/src/main/java/ast/BinaryCondition.java
+@@ -50,7 +50,6 @@ public class BinaryCondition extends Condition
+ 
+     public void changeLeft(Condition left)
+     {
+-        l.setParent(null);
+         l = left;
+         l.setParent(this);
+     }
+@@ -62,7 +61,6 @@ public class BinaryCondition extends Condition
+ 
+     public void changeRight(Condition right)
+     {
+-        r.setParent(null);
+         r = right;
+         r.setParent(this);
+     }
+diff --git a/src/main/java/ast/BinaryOp.java b/src/main/java/ast/BinaryOp.java
+index e3f70c2..380dc27 100644
+--- a/src/main/java/ast/BinaryOp.java
++++ b/src/main/java/ast/BinaryOp.java
+@@ -85,7 +85,6 @@ public class BinaryOp extends Expr
+ 
+     public void changeLeft(Expr l)
+     {
+-        left.setParent(null);
+         left = l;
+         left.setParent(this);
+     }
+diff --git a/src/main/java/ast/Duplicate.java b/src/main/java/ast/Duplicate.java
+index 98742de..9314953 100644
+--- a/src/main/java/ast/Duplicate.java
++++ b/src/main/java/ast/Duplicate.java
+@@ -84,12 +84,6 @@ public class Duplicate extends SearchMutation
+         throw new UnsupportedOperationException();
+     }
+ 
+-    @Override
+-    public void visit(Negative node)
+-    {
+-        throw new UnsupportedOperationException();
+-    }
+-
+     @Override
+     public void visit(NearbySensor node)
+     {
+@@ -121,7 +115,7 @@ public class Duplicate extends SearchMutation
+         List<Node> children = node.getChildren();
+         int size = children.size();
+         Node lastChild = children.get(size - 1);
+-        if (lastChild instanceof Action)
++        if (lastChild instanceof Action && subtrees.size() > 0)
+         {
+             int index = super.pickElement(subtrees);
+             Update clone = (Update) (subtrees.get(index).clone());
+@@ -129,7 +123,7 @@ public class Duplicate extends SearchMutation
+             children.set(size - 1, clone);
+             children.add(lastChild);
+         }
+-        else
++        else if (lastChild instanceof Update)
+         {
+             List<Node> actionSubtrees = super.findSubtrees(new Action(TokenType.WAIT));
+             subtrees.addAll(actionSubtrees);
+diff --git a/src/main/java/ast/Insert.java b/src/main/java/ast/Insert.java
+index 5013a1a..d1a4c3d 100644
+--- a/src/main/java/ast/Insert.java
++++ b/src/main/java/ast/Insert.java
+@@ -145,12 +145,6 @@ public class Insert extends SearchMutation
+         visitExpr(node);
+     }
+ 
+-    @Override
+-    public void visit(Negative node)
+-    {
+-        throw new UnsupportedOperationException();
+-    }
+-
+     @Override
+     public void visit(NearbySensor node)
+     {
+diff --git a/src/main/java/ast/Mem.java b/src/main/java/ast/Mem.java
+index 168d514..54f2d59 100644
+--- a/src/main/java/ast/Mem.java
++++ b/src/main/java/ast/Mem.java
+@@ -78,7 +78,8 @@ public class Mem extends Expr
+     }
+ 
+     @Override
+-    public StringBuilder prettyPrint(StringBuilder sb) {
++    public StringBuilder prettyPrint(StringBuilder sb)
++    {
+         sb.append("mem[");
+         this.e.prettyPrint(sb);
+         sb.append("]");
+@@ -92,9 +93,8 @@ public class Mem extends Expr
+ 
+     public void changeExpr(Expr e)
+     {
+-        this.e.setParent(null);
+         this.e = e;
+-        this.setParent(this);
++        e.setParent(this);
+     }
+ 
+     @Override
+diff --git a/src/main/java/ast/NearbySensor.java b/src/main/java/ast/NearbySensor.java
+index 8dd7796..d58bd39 100644
+--- a/src/main/java/ast/NearbySensor.java
++++ b/src/main/java/ast/NearbySensor.java
+@@ -1,5 +1,6 @@
+ package ast;
+ 
++import java.util.ArrayList;
+ import java.util.List;
+ 
+ public class NearbySensor extends Sensor
+@@ -32,8 +33,9 @@ public class NearbySensor extends Sensor
+     }
+ 
+     @Override
+-    public List<Node> getChildren() {
+-        return null;
++    public List<Node> getChildren()
++    {
++        return new ArrayList<>();
+     }
+ 
+     @Override
+diff --git a/src/main/java/ast/Negative.java b/src/main/java/ast/Negative.java
+deleted file mode 100644
+index 5130806..0000000
+--- a/src/main/java/ast/Negative.java
++++ /dev/null
+@@ -1,40 +0,0 @@
+-package ast;
+-
+-import java.util.List;
+-
+-public class Negative extends AbstractNode
+-{
+-    @Override
+-    public List<Node> getChildren() {
+-        return null;
+-    }
+-
+-    @Override
+-    public StringBuilder prettyPrint(StringBuilder sb) {
+-        sb.append("-");
+-        return sb;
+-    }
+-
+-    @Override
+-    public Node clone() {
+-        return new Negative();
+-    }
+-
+-    @Override
+-    public NodeCategory getCategory() {
+-        return null;
+-    }
+-
+-    @Override
+-    public void accept(Visitor v)
+-    {
+-        v.visit(this);
+-    }
+-
+-
+-    @Override
+-    public boolean classInv()
+-    {
+-        return true;
+-    }
+-}
+diff --git a/src/main/java/ast/NegativeExpr.java b/src/main/java/ast/NegativeExpr.java
+index f3bed74..ac5a53d 100644
+--- a/src/main/java/ast/NegativeExpr.java
++++ b/src/main/java/ast/NegativeExpr.java
+@@ -5,31 +5,27 @@ import java.util.List;
+ 
+ public class NegativeExpr extends Expr
+ {
+-    private Negative negativeNode;
+     private Expr factor;
+ 
+-    public NegativeExpr(Negative negativeNode, Expr factor)
++    public NegativeExpr(Expr factor)
+     {
+-        this.negativeNode = negativeNode;
+         this.factor = factor;
+-        this.negativeNode.setParent(this);
+         this.factor.setParent(this);
+     }
+ 
+     @Override
+-    public Node clone(){
+-        Negative clonedNegativeNode =  (Negative) this.negativeNode.clone();
++    public Node clone()
++    {
+         Expr clonedFactor =  (Expr) this.factor.clone();
+-        NegativeExpr cloned = new NegativeExpr(clonedNegativeNode, clonedFactor);
+-        clonedNegativeNode.setParent(cloned);
++        NegativeExpr cloned = new NegativeExpr(clonedFactor);
+         clonedFactor.setParent(cloned);
+         return cloned;
+     }
+ 
+     @Override
+-    public List<Node> getChildren() {
++    public List<Node> getChildren()
++    {
+         ArrayList<Node> children = new ArrayList<>();
+-        children.add(negativeNode);
+         children.add(factor);
+         return children;
+     }
+@@ -37,17 +33,12 @@ public class NegativeExpr extends Expr
+     @Override
+     public StringBuilder prettyPrint(StringBuilder sb)
+     {
+-        negativeNode.prettyPrint(sb);
+-        sb.append(" ");
++        sb.append("-");
++//        sb.append(" ");
+         factor.prettyPrint(sb);
+         return sb;
+     }
+ 
+-    public Negative getLeft()
+-    {
+-        return negativeNode;
+-    }
+-
+     public Expr getRight()
+     {
+         return factor;
+@@ -70,6 +61,6 @@ public class NegativeExpr extends Expr
+     @Override
+     public boolean classInv()
+     {
+-        return (negativeNode.classInv() && factor.classInv());
++        return factor.classInv();
+     }
+ }
+diff --git a/src/main/java/ast/Number.java b/src/main/java/ast/Number.java
+index ce8566c..9671724 100644
+--- a/src/main/java/ast/Number.java
++++ b/src/main/java/ast/Number.java
+@@ -1,5 +1,6 @@
+ package ast;
+ 
++import java.util.ArrayList;
+ import java.util.List;
+ 
+ public class Number extends Expr
+@@ -35,7 +36,7 @@ public class Number extends Expr
+     @Override
+     public List<Node> getChildren()
+     {
+-        return null;
++        return new ArrayList<Node>();
+     }
+ 
+     @Override
+diff --git a/src/main/java/ast/ProgramImpl.java b/src/main/java/ast/ProgramImpl.java
+index 0db03aa..11c1f28 100644
+--- a/src/main/java/ast/ProgramImpl.java
++++ b/src/main/java/ast/ProgramImpl.java
+@@ -33,11 +33,14 @@ public class ProgramImpl extends AbstractNode implements Program
+     @Override
+     public StringBuilder prettyPrint(StringBuilder sb)
+     {
+-        for(Node child : getChildren())
++        List<Node> children = this.getChildren();
++        for(Node child : children)
+         {
+             child.prettyPrint(sb);
+-            sb.append(";");
+-            sb.append(System.lineSeparator());
++            if (child != children.get(children.size() - 1))
++            {
++                sb.append(System.lineSeparator());
++            }
+         }
+         return sb;
+     }
+@@ -82,8 +85,9 @@ public class ProgramImpl extends AbstractNode implements Program
+     @Override
+     public Program mutate()
+     {
++        int size = this.size();
+         int randomMut = (int)(Math.random() * 6);
+-        int randomNode = (int)(Math.random() * this.size());
++        int randomNode = (int)(Math.random() * size);
+         Mutation m;
+ 
+         if(randomMut == 0)
+@@ -116,6 +120,12 @@ public class ProgramImpl extends AbstractNode implements Program
+             m = MutationFactory.getDuplicate();
+         }
+ 
++        int count = 0;
++        while (!m.canApply(this.nodeAt(randomNode)) && count < size)
++        {
++            randomNode = (int)(Math.random() * size);
++            count++;
++        }
+         m.apply(this, this.nodeAt(randomNode));
+         return this;
+     }
+diff --git a/src/main/java/ast/Remove.java b/src/main/java/ast/Remove.java
+index af7d5ca..0645b7d 100644
+--- a/src/main/java/ast/Remove.java
++++ b/src/main/java/ast/Remove.java
+@@ -29,7 +29,7 @@ public class Remove extends AbstractMutation
+     public boolean canApply(Node n)
+     {
+         if (n instanceof ProgramImpl || n instanceof Relation || n instanceof Number
+-                || n instanceof Negative || n instanceof SmellSensor || n instanceof Command)
++                || n instanceof SmellSensor || n instanceof Command)
+         {
+             return false;
+         }
+@@ -59,7 +59,6 @@ public class Remove extends AbstractMutation
+         {
+             parent.remove(node);
+         }
+-        node.setParent(null);
+     }
+ 
+     @Override
+@@ -71,8 +70,6 @@ public class Remove extends AbstractMutation
+         {
+             Condition child = childPicker == 0 ? node.getLeft() : node.getRight();
+             ((Rule) parent).changeCondition(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof BinaryCondition)
+         {
+@@ -85,8 +82,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryCondition) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+     }
+ 
+@@ -112,8 +107,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryOp) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof Relation)
+         {
+@@ -126,15 +119,11 @@ public class Remove extends AbstractMutation
+             {
+                 ((Relation) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Update)
+         {
+             Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
+             ((Update) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Action)
+         {
+@@ -142,8 +131,6 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
+                 ((Action) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+ //            else
+ //            {
+@@ -154,8 +141,6 @@ public class Remove extends AbstractMutation
+         {
+             Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
+             ((Mem) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Sensor)
+         {
+@@ -163,22 +148,16 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
+                 ((NearbySensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof AheadSensor)
+             {
+                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
+-                ((AheadSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
++                ((AheadSensor) parent).changeExpr(child);;
+             }
+             else if (parent instanceof RandomSensor)
+             {
+                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
+                 ((RandomSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+         }
+     }
+@@ -204,8 +183,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryOp) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof Relation)
+         {
+@@ -218,8 +195,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((Relation) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Update)
+         {
+@@ -232,8 +207,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((Update) parent).changeExpr(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Action)
+         {
+@@ -241,8 +214,6 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((Action) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+ //            else
+ //            {
+@@ -253,15 +224,11 @@ public class Remove extends AbstractMutation
+         {
+             Expr child = node.getExpr();
+             ((Mem) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof NegativeExpr)
+         {
+             Expr child = node.getExpr();
+             ((NegativeExpr) parent).changeRight(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Sensor)
+         {
+@@ -269,22 +236,16 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((NearbySensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof AheadSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((AheadSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof RandomSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((RandomSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+         }
+     }
+@@ -304,8 +265,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryOp) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof Relation)
+         {
+@@ -318,15 +277,11 @@ public class Remove extends AbstractMutation
+             {
+                 ((Relation) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Update)
+         {
+             Expr child = node.getRight();
+             ((Update) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Action)
+         {
+@@ -334,8 +289,6 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getRight();
+                 ((Action) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+ //            else
+ //            {
+@@ -346,15 +299,11 @@ public class Remove extends AbstractMutation
+         {
+             Expr child = node.getRight();
+             ((Mem) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof NegativeExpr)
+         {
+             Expr child = node.getRight();
+             ((NegativeExpr) parent).changeRight(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Sensor)
+         {
+@@ -362,32 +311,20 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getRight();
+                 ((NearbySensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof AheadSensor)
+             {
+                 Expr child = node.getRight();
+                 ((AheadSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof RandomSensor)
+             {
+                 Expr child = node.getRight();
+                 ((RandomSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+         }
+     }
+ 
+-    @Override
+-    public void visit(Negative node)
+-    {
+-        throw new UnsupportedOperationException();
+-    }
+-
+     @Override
+     public void visit(NearbySensor node)
+     {
+@@ -403,8 +340,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryOp) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof Relation)
+         {
+@@ -417,15 +352,11 @@ public class Remove extends AbstractMutation
+             {
+                 ((Relation) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Update)
+         {
+             Expr child = node.getExpr();
+             ((Update) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Action)
+         {
+@@ -433,8 +364,6 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((Action) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+ //            else
+ //            {
+@@ -445,15 +374,11 @@ public class Remove extends AbstractMutation
+         {
+             Expr child = node.getExpr();
+             ((Mem) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof NegativeExpr)
+         {
+             Expr child = node.getExpr();
+             ((NegativeExpr) parent).changeRight(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Sensor)
+         {
+@@ -461,22 +386,16 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((NearbySensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof AheadSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((AheadSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof RandomSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((RandomSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+         }
+     }
+@@ -496,8 +415,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryOp) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof Relation)
+         {
+@@ -510,15 +427,11 @@ public class Remove extends AbstractMutation
+             {
+                 ((Relation) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Update)
+         {
+             Expr child = node.getExpr();
+             ((Update) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Action)
+         {
+@@ -526,8 +439,6 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((Action) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+ //            else
+ //            {
+@@ -538,15 +449,11 @@ public class Remove extends AbstractMutation
+         {
+             Expr child = node.getExpr();
+             ((Mem) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof NegativeExpr)
+         {
+             Expr child = node.getExpr();
+             ((NegativeExpr) parent).changeRight(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Sensor)
+         {
+@@ -554,22 +461,16 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((NearbySensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof AheadSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((AheadSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof RandomSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((RandomSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+         }
+     }
+@@ -589,8 +490,6 @@ public class Remove extends AbstractMutation
+             {
+                 ((BinaryOp) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         if (parent instanceof Relation)
+         {
+@@ -603,15 +502,11 @@ public class Remove extends AbstractMutation
+             {
+                 ((Relation) parent).changeRight(child);
+             }
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Update)
+         {
+             Expr child = node.getExpr();
+             ((Update) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Action)
+         {
+@@ -619,8 +514,6 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((Action) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+ //            else
+ //            {
+@@ -631,15 +524,11 @@ public class Remove extends AbstractMutation
+         {
+             Expr child = node.getExpr();
+             ((Mem) parent).changeExpr(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof NegativeExpr)
+         {
+             Expr child = node.getExpr();
+             ((NegativeExpr) parent).changeRight(child);
+-            child.setParent(parent);
+-            node.setParent(null);
+         }
+         else if (parent instanceof Sensor)
+         {
+@@ -647,22 +536,16 @@ public class Remove extends AbstractMutation
+             {
+                 Expr child = node.getExpr();
+                 ((NearbySensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof AheadSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((AheadSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+             else if (parent instanceof RandomSensor)
+             {
+                 Expr child = node.getExpr();
+                 ((RandomSensor) parent).changeExpr(child);
+-                child.setParent(parent);
+-                node.setParent(null);
+             }
+         }
+     }
+@@ -686,7 +569,6 @@ public class Remove extends AbstractMutation
+         if (((Command) parent).getChildren().size() > 1)
+         {
+             ((Command) parent).remove(node);
+-            node.setParent(null);
+         }
+     }
+ 
+@@ -697,7 +579,6 @@ public class Remove extends AbstractMutation
+         if (((Command) parent).getChildren().size() > 1)
+         {
+             ((Command) parent).remove(node);
+-            node.setParent(null);
+         }
+     }
+ }
+diff --git a/src/main/java/ast/Replace.java b/src/main/java/ast/Replace.java
+index 60ea270..2358920 100644
+--- a/src/main/java/ast/Replace.java
++++ b/src/main/java/ast/Replace.java
+@@ -29,7 +29,7 @@ public class Replace extends SearchMutation
+     @Override
+     public boolean canApply(Node n)
+     {
+-        return !(n instanceof ProgramImpl || n instanceof Negative);
++        return !(n instanceof ProgramImpl);
+     }
+ 
+     @Override
+@@ -47,8 +47,6 @@ public class Replace extends SearchMutation
+         Node parent = node.getParent();
+         Rule clone = (Rule) (replacementNode.clone());
+         ((ProgramImpl) parent).replace(node, clone);
+-        clone.setParent(parent);
+-        node.setParent(null);
+     }
+ 
+     @Override
+@@ -59,8 +57,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Condition clone = (Condition) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof Rule)
+         {
+             ((Rule) parent).changeCondition(clone);
+@@ -86,8 +82,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Condition clone = (Condition) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof Rule)
+         {
+             ((Rule) parent).changeCondition(clone);
+@@ -112,9 +106,7 @@ public class Replace extends SearchMutation
+         int index = super.pickElement(subtrees);
+         Node replacementNode = subtrees.get(index);
+         Node parent = node.getParent();
+-        node.setParent(null);
+         Expr clone = (Expr) (replacementNode.clone());
+-        clone.setParent(parent);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -181,8 +173,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -249,8 +239,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -283,10 +271,8 @@ public class Replace extends SearchMutation
+                         iter.remove();
+                     }
+                 }
+-                clone.setParent(null);
+                 index = super.pickElement(subtrees);
+                 Mem newClone = (Mem) (subtrees.get(index));
+-                newClone.setParent(parent);
+                 ((Update) parent).changeMemType(newClone);
+             }
+             else
+@@ -334,8 +320,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -394,12 +378,6 @@ public class Replace extends SearchMutation
+         }
+     }
+ 
+-    @Override
+-    public void visit(Negative node)
+-    {
+-        throw new UnsupportedOperationException();
+-    }
+-
+     @Override
+     public void visit(NearbySensor node)
+     {
+@@ -408,8 +386,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -476,8 +452,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -544,8 +518,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -612,8 +584,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Expr clone = (Expr) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         if (parent instanceof BinaryOp)
+         {
+             if (node == ((BinaryOp) parent).getLeft())
+@@ -680,8 +650,10 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Command clone = (Command) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
++        if (parent == null)
++        {
++            System.out.println("parent is null");
++        }
+         ((Rule) parent).changeCommand(clone);
+     }
+ 
+@@ -693,8 +665,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Update clone = (Update) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         ((Command) parent).replace(node, clone);
+     }
+ 
+@@ -706,8 +676,6 @@ public class Replace extends SearchMutation
+         Node replacementNode = subtrees.get(index);
+         Action clone = (Action) (replacementNode.clone());
+         Node parent = node.getParent();
+-        clone.setParent(parent);
+-        node.setParent(null);
+         ((Command) parent).replace(node, clone);
+     }
+ }
+diff --git a/src/main/java/ast/Rule.java b/src/main/java/ast/Rule.java
+index 3efc40c..ec02d1d 100644
+--- a/src/main/java/ast/Rule.java
++++ b/src/main/java/ast/Rule.java
+@@ -32,6 +32,7 @@ public class Rule extends AbstractNode {
+         condition.prettyPrint(sb);
+         sb.append((" --> "));
+         command.prettyPrint(sb);
++        sb.append(";");
+ 
+         return sb;
+     }
+@@ -69,7 +70,8 @@ public class Rule extends AbstractNode {
+     }
+ 
+     @Override
+-    public NodeCategory getCategory() {
++    public NodeCategory getCategory()
++    {
+         return NodeCategory.RULE;
+     }
+ 
+diff --git a/src/main/java/ast/SmellSensor.java b/src/main/java/ast/SmellSensor.java
+index 958b238..e107488 100644
+--- a/src/main/java/ast/SmellSensor.java
++++ b/src/main/java/ast/SmellSensor.java
+@@ -1,5 +1,7 @@
+ package ast;
+ 
++import java.util.ArrayList;
++import java.util.Collections;
+ import java.util.List;
+ 
+ public class SmellSensor extends Sensor
+@@ -18,7 +20,7 @@ public class SmellSensor extends Sensor
+ 
+     @Override
+     public List<Node> getChildren() {
+-        return null;
++        return new ArrayList<>();
+     }
+ 
+     @Override
+diff --git a/src/main/java/ast/Swap.java b/src/main/java/ast/Swap.java
+index 2cca601..214bc4e 100644
+--- a/src/main/java/ast/Swap.java
++++ b/src/main/java/ast/Swap.java
+@@ -114,12 +114,6 @@ public class Swap extends AbstractMutation
+         throw new UnsupportedOperationException();
+     }
+ 
+-    @Override
+-    public void visit(Negative node)
+-    {
+-        throw new UnsupportedOperationException();
+-    }
+-
+     @Override
+     public void visit(NearbySensor node)
+     {
+@@ -154,20 +148,20 @@ public class Swap extends AbstractMutation
+             int childPicker2;
+             if (children.get(children.size() - 1) instanceof Action)
+             {
+-                childPicker1 = (int) (Math.random() * children.size());
+-                childPicker2 = (int) (Math.random() * children.size());
++                childPicker1 = (int) (Math.random() * children.size() - 1);
++                childPicker2 = (int) (Math.random() * children.size() - 1);
+             }
+             else
+             {
+-                childPicker1 = (int) (Math.random() * (children.size() - 1));
+-                childPicker2 = (int) (Math.random() * (children.size() - 1));
++                childPicker1 = (int) (Math.random() * (children.size()));
++                childPicker2 = (int) (Math.random() * (children.size()));
+             }
+             while (childPicker1 == childPicker2)
+             {
+                 childPicker2 = (int) (Math.random() * node.getChildren().size());
+             }
+-            Node temp = node.getChildren().get(childPicker1);
+-            Node temp2 = node.getChildren().get(childPicker2);
++            Node temp = children.get(childPicker1);
++            Node temp2 = children.get(childPicker2);
+             node.getChildren().set(childPicker1, temp2);
+             node.getChildren().set(childPicker2, temp);
+         }
+diff --git a/src/main/java/ast/Transform.java b/src/main/java/ast/Transform.java
+index 4188762..5e67d9d 100644
+--- a/src/main/java/ast/Transform.java
++++ b/src/main/java/ast/Transform.java
+@@ -137,12 +137,6 @@ public class Transform extends AbstractMutation
+         throw new UnsupportedOperationException();
+     }
+ 
+-    @Override
+-    public void visit(Negative node)
+-    {
+-        throw new UnsupportedOperationException();
+-    }
+-
+     @Override
+     public void visit(NearbySensor node)
+     {
+diff --git a/src/main/java/ast/Visitor.java b/src/main/java/ast/Visitor.java
+index a0d6ca9..16a0770 100644
+--- a/src/main/java/ast/Visitor.java
++++ b/src/main/java/ast/Visitor.java
+@@ -18,8 +18,6 @@ public interface Visitor
+ 
+     void visit(NegativeExpr node);
+ 
+-    void visit(Negative node);
+-
+     void visit(NearbySensor node);
+ 
+     void visit(AheadSensor node);
+diff --git a/src/main/java/console/Console.java b/src/main/java/console/Console.java
+new file mode 100644
+index 0000000..054ea64
+--- /dev/null
++++ b/src/main/java/console/Console.java
+@@ -0,0 +1,147 @@
++package console;
++
++import cms.util.maybe.Maybe;
++import controller.Controller;
++import controller.ControllerFactory;
++import java.util.Arrays;
++import java.util.Scanner;
++import java.util.stream.Collectors;
++import model.ReadOnlyCritter;
++import model.ReadOnlyWorld;
++
++/**
++ * The provided shows you how the course staff may call the methods in Controller to test your code.
++ *
++ * <p>You don't need to modify anything in this file. You can choose to make it prettier, but you
++ * still need to support the same set of commands and print out the same set of information.
++ *
++ * <p>NEVER remove this file, since it will be your entry point of the JAR file.
++ */
++public final class Console
++{
++    private final Controller controller = ControllerFactory.getConsoleController();
++    private final Scanner scan = new Scanner(System.in);
++
++    private Console() {}
++
++    /* =========================== */
++    /* DO NOT EDIT ABOVE THIS LINE */
++    /* (except imports...) */
++    /* =========================== */
++
++    /** Prints current time step, number of critters, and world map of the simulation. */
++    private void worldInfo() {
++        ReadOnlyWorld world = controller.getReadOnlyWorld();
++        System.out.println("steps: " + world.getSteps());
++        System.out.println("critters: " + world.getNumberOfAliveCritters());
++        controller.printWorld(System.out);
++    }
++
++    /**
++     * Prints description of the contents of hex (c,r).
++     *
++     * @param c column of hex
++     * @param r row of hex
++     */
++    private void hexInfo(int c, int r) {
++        ReadOnlyWorld world = controller.getReadOnlyWorld();
++        Maybe<ReadOnlyCritter> maybeCritter = world.getReadOnlyCritter(c, r);
++        maybeCritter.thenElse(critter -> {
++            System.out.println("Species: " + critter.getSpecies());
++            String memory =
++                    Arrays.stream(critter.getMemory())
++                            .mapToObj(String::valueOf)
++                            .collect(Collectors.joining(" "));
++            System.out.println("Memory:" + memory);
++            System.out.println("Program: " + critter.getProgramString());
++            System.out.println("Last rule: " + critter.getLastRuleString());
++        }, () -> {
++            int terrain = world.getTerrainInfo(c, r);
++            if (terrain == 0) {
++                System.out.println("Empty");
++            } else if (terrain == -1) {
++                System.out.println("Rock");
++            } else if (terrain > 0){
++                System.out.println("Critter");
++            } else {
++                System.out.println("Food: " + (-terrain - 1));
++            }
++        });
++    }
++
++    /* =========================== */
++    /* DO NOT EDIT BELOW THIS LINE */
++    /* =========================== */
++
++    /** Prints a list of possible commands to the standard output. */
++    private void printHelp() {
++        System.out.println("new: start a new simulation with a random world");
++        System.out.println(
++                "load <world_file>: start a new simulation with the world loaded from world_file");
++        System.out.println(
++                "critters <critter_file> <n>: add n critters defined by critter_file randomly into the world");
++        System.out.println("step <n>: advance the world by n timesteps");
++        System.out.println(
++                "info: print current timestep, number of critters living, and map of world");
++        System.out.println("hex <c> <r>: print contents of hex at column c, row r");
++        System.out.println("exit: exit the program");
++    }
++
++    /**
++     * Processes a single console command provided by the user.
++     *
++     * @return whether we should continue handling commands.
++     */
++    private boolean handleCommand() {
++        System.out.print("Enter a command or \"help\" for a list of commands.\n> ");
++        String command = scan.next();
++        switch (command) {
++            case "new":
++                controller.newWorld();
++                break;
++            case "load":
++                {
++                    String filename = scan.next();
++                    controller.loadWorld(filename, true, false);
++                    break;
++                }
++            case "critters":
++                {
++                    String filename = scan.next();
++                    int n = scan.nextInt();
++                    controller.loadCritters(filename, n);
++                    break;
++                }
++            case "step":
++                {
++                    int n = scan.nextInt();
++                    controller.advanceTime(n);
++                    break;
++                }
++            case "info":
++                worldInfo();
++                break;
++            case "hex":
++                {
++                    int c = scan.nextInt();
++                    int r = scan.nextInt();
++                    hexInfo(c, r);
++                    break;
++                }
++            case "help":
++                printHelp();
++                break;
++            case "exit":
++                return false;
++            default:
++                System.out.println(command + " is not a valid command.");
++        }
++        return true;
++    }
++
++    public static void main(String[] args)
++    {
++        Console console = new Console();
++        while (console.handleCommand()) ;
++    }
++}
+diff --git a/src/main/java/controller/Controller.java b/src/main/java/controller/Controller.java
+new file mode 100644
+index 0000000..55372f7
+--- /dev/null
++++ b/src/main/java/controller/Controller.java
+@@ -0,0 +1,59 @@
++package controller;
++
++import java.io.PrintStream;
++import model.ReadOnlyWorld;
++
++/**
++ * Controller interface that allows the course staff to test your critter world implementation.
++ *
++ * <p>NEVER remove or change any methods in this file except reformatting. Feel free to add
++ * additional methods in this file. It might be helpful in later assignments.
++ *
++ * <p>You have to provide one implementation of {@code ConsoleController} to {@code
++ * ControllerFactory}.
++ */
++public interface Controller
++{
++    /** @return the readonly world. */
++    ReadOnlyWorld getReadOnlyWorld();
++
++    /** Starts new random world simulation. */
++    void newWorld();
++
++    /**
++     * Starts new simulation with world specified in filename.
++     *
++     * @param filename name of the world file.
++     * @param enableManna if enableManna is false, then the world should not drop any manna.
++     * This is important for deterministic unit testing.
++     * @param enableForcedMutation if enableForcedMutation is true, then a critter's program
++     * will mutate every time it finishes its action.
++     * @return whether the world is successfully loaded.
++     */
++    boolean loadWorld(String filename, boolean enableManna, boolean enableForcedMutation);
++
++    /**
++     * Loads critter definition from filename and randomly places n critters with that definition
++     * into the world.
++     *
++     * @param filename name of the critter spec file.
++     * @param n number of critter to add.
++     * @return whether all critters are successfully loaded.
++     */
++    boolean loadCritters(String filename, int n);
++
++    /**
++     * Advances the world by n time steps.
++     *
++     * @param n number of steps.
++     * @return false if the world has not been initialized or n is negative, true otherwise.
++     */
++    boolean advanceTime(int n);
++
++    /**
++     * Print the world to the specified stream.
++     *
++     * @param out the stream to print the world.
++     */
++    void printWorld(PrintStream out);
++}
+diff --git a/src/main/java/controller/ControllerFactory.java b/src/main/java/controller/ControllerFactory.java
+new file mode 100644
+index 0000000..377d319
+--- /dev/null
++++ b/src/main/java/controller/ControllerFactory.java
+@@ -0,0 +1,21 @@
++package controller;
++
++/** DO NOT REMOVE ANY METHODS IN THIS CLASS. Course staff needs this to test your world. */
++public final class ControllerFactory
++{
++
++    /**
++     * Private constructor can prevent any {@code new ControllerFactory()} since they do not make
++     * sense.
++     */
++    private ControllerFactory() {}
++
++    /**
++     * @return a controller for console to allow course staff to test your code. The returned
++     *     controller contains a randomly initialized world.
++     */
++    public static Controller getConsoleController()
++    {
++        return new ControllerImpl();
++    }
++}
+diff --git a/src/main/java/controller/ControllerImpl.java b/src/main/java/controller/ControllerImpl.java
+new file mode 100644
+index 0000000..01deb25
+--- /dev/null
++++ b/src/main/java/controller/ControllerImpl.java
+@@ -0,0 +1,228 @@
++package controller;
++
++import ast.Program;
++import exceptions.SyntaxError;
++import model.*;
++import parse.Parser;
++import parse.ParserFactory;
++
++import java.io.FileNotFoundException;
++import java.io.PrintStream;
++import java.io.File;
++import java.io.Reader;
++import java.io.FileReader;
++import java.io.IOException;
++import java.util.Arrays;
++import java.util.Scanner;
++
++public class ControllerImpl implements Controller
++{
++    private ControlOnlyWorld controlWorld;
++    private ReadOnlyWorld readOnlyWorld;
++    private boolean enableManna;
++    private boolean enableForcedMutation;
++
++    @Override
++    public ReadOnlyWorld getReadOnlyWorld()
++    {
++        return readOnlyWorld;
++    }
++
++    @Override
++    public void newWorld()
++    {
++        World world = new World();
++        controlWorld = world;
++        readOnlyWorld = world;
++    }
++
++    @Override
++    public boolean loadWorld(String filename, boolean enableManna, boolean enableForcedMutation)
++    {
++        // TODO fix coordinates
++        this.enableManna = enableManna;
++        this.enableForcedMutation = enableForcedMutation;
++
++        File worldFile = new File(filename);
++        try
++        {
++            Scanner sc = new Scanner(worldFile);
++            sc.next();
++            System.out.println(sc.nextLine().substring(1));
++            sc.next();
++            int width = sc.nextInt();
++            int height = sc.nextInt();
++            World world = new World(width, height, enableManna, enableForcedMutation);
++            controlWorld = world;
++            readOnlyWorld = world;
++            while (sc.hasNext())
++            {
++                String object = sc.next();
++                if (object.startsWith("//"))
++                {
++                    sc.nextLine();
++                }
++                else if (object.equals("rock"))
++                {
++                    int column = sc.nextInt();
++                    int row = sc.nextInt();
++                    controlWorld.addRock(row, column);
++                }
++                else if (object.equals("food"))
++                {
++                    int column = sc.nextInt();
++                    int row = sc.nextInt();
++                    int amount = sc.nextInt();
++                    controlWorld.addFood(row, column, amount);
++                }
++                else if (object.equals("critter"))
++                {
++                    String critterFile = sc.next();
++                    int column = sc.nextInt();
++                    int row = sc.nextInt();
++                    int direction = sc.nextInt();
++                    if ((row + column) % 2 == 0)
++                    {
++                        Object[] critterInfo = parseCritterFile(worldFile.getParent() + "\\" + critterFile);
++//                    System.out.println(Arrays.toString(critterInfo));
++                        controlWorld.addCritter((String) critterInfo[0], (int[]) critterInfo[1], (Program) critterInfo[2],
++                                row, column, direction);
++                    }
++                }
++            }
++            return true;
++        }
++        catch (FileNotFoundException e)
++        {
++            System.out.println("please input a valid world file");
++        }
++        return false;
++    }
++
++    @Override
++    public boolean loadCritters(String filename, int n)
++    {
++        Object[] critterInfo = parseCritterFile(filename);
++        if (critterInfo != null)
++        {
++            for (int i = 0; i < n; i++)
++            {
++                controlWorld.addCritter((String) critterInfo[0], (int[]) critterInfo[1], (Program) critterInfo[2]);
++            }
++            return true;
++        }
++        return false;
++    }
++
++    @Override
++    public boolean advanceTime(int n)
++    {
++        if (controlWorld == null || n < 0)
++        {
++            return false;
++        }
++        for (int i = 0; i < n; i++)
++        {
++            controlWorld.advanceTimeStep();
++            if(enableForcedMutation) controlWorld.forcedMutate();
++            if(enableManna) controlWorld.addManna();
++        }
++        return true;
++    }
++
++    @Override
++    public void printWorld(PrintStream out)
++    {
++        controlWorld.printWorld(out);
++    }
++
++    public Object[] parseCritterFile(String filename)
++    {
++        try
++        {
++//            System.out.println(filename);
++            Reader r = new FileReader(filename);
++//            System.out.println("passed 1");
++            String species = "";
++            Program ast;
++            int[] mem = new int[Constants.MIN_MEMORY];
++//            int row;
++//            int column;
++//            int direction;
++            int line = 1;
++            String text = "";
++            while (line <= 7)
++            {
++                text = "";
++                int i;
++                while ((char) (i = r.read()) != '\n')
++                {
++                    text += (char) i;
++                }
++                if (text.endsWith("\r"))
++                {
++                    text = text.substring(0, text.length() - 1);
++                }
++//                System.out.println(text + ", line " + line);
++                if (text.startsWith("//") || text.equals(""))
++                {
++                    continue;
++                }
++                else if (text.startsWith("species: ") && line == 1)
++                {
++                    species = text.substring(9);
++                }
++                else if (text.startsWith("memsize: ") && line == 2)
++                {
++                    int memsize = Integer.parseInt(text.substring(9));
++                    mem = memsize > Constants.MIN_MEMORY ? new int[memsize] : mem;
++                    mem[0] = memsize;
++                    mem[5] = 1;
++                }
++                else if (text.startsWith("defense: ") && line == 3)
++                {
++                    int num = Integer.parseInt(text.substring(9));
++                    mem[1] = num;
++                }
++                else if (text.startsWith("offense: ") && line == 4)
++                {
++                    int num = Integer.parseInt(text.substring(9));
++                    mem[2] = num;
++                }
++                else if (text.startsWith("size: ") && line == 5)
++                {
++                    int num = Integer.parseInt(text.substring(6));
++                    mem[3] = num;
++                }
++                else if (text.startsWith("energy: ") && line == 6)
++                {
++                    int num = Integer.parseInt(text.substring(8));
++                    mem[4] = num;
++                }
++                else if (text.startsWith("posture: ") && line == 7)
++                {
++                    int num = Integer.parseInt(text.substring(9));
++                    mem[6] = num;
++                }
++                else
++                {
++                    throw new IOException();
++                }
++                line++;
++            }
++            Parser p = ParserFactory.getParser();
++            ast = p.parse(r);
++//            System.out.println(ast);
++            return new Object[]{species, mem, ast};
++        }
++        catch (IOException e)
++        {
++            System.out.println("please input a valid critter file");
++        }
++        catch (SyntaxError e)
++        {
++            System.out.println("a valid program should not have syntax errors");;
++        }
++        return null;
++    }
++}
+diff --git a/src/main/java/main/ParseAndMutateApp.java b/src/main/java/main/ParseAndMutateApp.java
+index 1a4fd17..7fafdaf 100644
+--- a/src/main/java/main/ParseAndMutateApp.java
++++ b/src/main/java/main/ParseAndMutateApp.java
+@@ -74,6 +74,7 @@ public class ParseAndMutateApp
+                         while (!(mut.canApply(target)) && count < 50)
+                         {
+                             target = prog.nodeAt((int) (Math.random() * prog.size()));
++                            count++;
+                         }
+                         mut.apply(prog, target);
+                         System.out.println(mut.getClass());
+diff --git a/src/main/java/model/Constants.java b/src/main/java/model/Constants.java
+new file mode 100644
+index 0000000..76db64c
+--- /dev/null
++++ b/src/main/java/model/Constants.java
+@@ -0,0 +1,32 @@
++package model;
++
++/**
++ * NEVER remove or change any constants in this file except reformatting. Feel free to add
++ * additional constants in this file.
++ */
++public final class Constants {
++
++    private Constants() {}
++
++    public static final int BASE_DAMAGE = 100;
++    public static final double DAMAGE_INC = .2;
++    public static final int ENERGY_PER_SIZE = 500;
++    public static final int FOOD_PER_SIZE = 200;
++    public static final int MAX_SMELL_DISTANCE = 10;
++    public static final int ROCK_VALUE = -1;
++    public static final int WIDTH = 50;
++    public static final int HEIGHT = 87;
++    public static final int MAX_RULES_PER_TURN = 999;
++    public static final int SOLAR_FLUX = 1;
++    public static final int MOVE_COST = 3;
++    public static final int ATTACK_COST = 5;
++    public static final int GROW_COST = 1;
++    public static final int BUD_COST = 9;
++    public static final int MATE_COST = 5;
++    public static final int RULE_COST = 2;
++    public static final int ABILITY_COST = 25;
++    public static final int INITIAL_ENERGY = 250;
++    public static final int MIN_MEMORY = 7;
++    public static final int MANNA_COUNT = 10;
++    public static final int MANNA_AMOUNT = 10;
++}
+diff --git a/src/main/java/model/ControlOnlyWorld.java b/src/main/java/model/ControlOnlyWorld.java
+new file mode 100644
+index 0000000..75de5a1
+--- /dev/null
++++ b/src/main/java/model/ControlOnlyWorld.java
+@@ -0,0 +1,25 @@
++package model;
++
++import ast.Program;
++
++import java.io.PrintStream;
++
++public abstract class ControlOnlyWorld
++{
++    public abstract boolean addCritter(String species, int[] mem, Program ast);
++
++    public abstract boolean addCritter(String species, int[] mem, Program ast, int row, int column, int dir);
++
++    public abstract boolean addRock(int row, int column);
++
++    public abstract boolean addFood(int row, int column, int amount);
++
++    public abstract void advanceTimeStep();
++
++    public abstract void printWorld(PrintStream out);
++
++    public abstract void forcedMutate();
++
++    public abstract void addManna();
++
++}
+diff --git a/src/main/java/model/Critter.java b/src/main/java/model/Critter.java
+new file mode 100644
+index 0000000..6cfa482
+--- /dev/null
++++ b/src/main/java/model/Critter.java
+@@ -0,0 +1,131 @@
++package model;
++
++import ast.Program;
++import cms.util.maybe.Maybe;
++
++public class Critter implements ReadOnlyCritter
++{
++    private String species;
++    private Program ast;
++    private int[] mem;
++    private int row;
++    private int column;
++    private int direction;
++    private String lastRuleString;
++    private boolean mating;
++    private boolean justCreated;
++
++    public Critter(String species, Program ast, int[] mem, int row, int column, int direction)
++    {
++        this.species = species;
++        this.ast = ast;
++        this.mem = mem;
++        this.row = row;
++        this.column = column;
++        this.direction = direction % 6 >= 0 ? direction % 6 : direction % 6 + 6; // idk if we should the mod 6 should be included
++        this.justCreated = true;
++    }
++
++    public Program getProgram()
++    {
++        return ast;
++    }
++
++//    public int[] getMem()
++//    {
++//        return mem;
++//    }
++
++    public boolean isMating()
++    {
++        return mating;
++    }
++
++    public boolean isJustCreated() {
++        return justCreated;
++    }
++
++    public void setJustcreated(boolean temp){
++        justCreated = temp;
++    }
++
++    public void setLastRuleString(String newRule)
++    {
++        lastRuleString = newRule;
++    }
++
++
++    public void setMating(boolean mating)
++    {
++        this.mating = mating;
++    }
++
++    public int getRow()
++    {
++        return row;
++    }
++
++    public int getColumn()
++    {
++        return column;
++    }
++
++    public void setPosition(int r, int c){
++        row = r;
++        column = c;
++    }
++
++    public void setDirection(int newDir){
++        direction = newDir;
++    }
++
++    public int energyCapacity(){
++        return mem[3] *  Constants.ENERGY_PER_SIZE;
++    }
++
++    public int complexity(){
++        return ast.getChildren().size() * Constants.RULE_COST + (mem[1] + mem[2]) * Constants.ABILITY_COST;
++    }
++
++    public int getDirection()
++    {
++        return direction;
++    }
++
++    public int getMemValue(int index)
++    {
++        return index >= 0 && index < mem.length ? mem[index] : 0;
++    }
++
++    public void setMem(int index, int newNum)
++    {
++        if ((index >= 3 && index <= 5 && newNum >= 1) || (index == 6 && newNum >= 0 && newNum <= 99))
++        {
++            mem[index] = newNum;
++        }
++    }
++
++    @Override
++    public String getSpecies()
++    {
++        return species;
++    }
++
++    @Override
++    public int[] getMemory()
++    {
++        return mem.clone();
++    }
++
++    @Override
++    public String getProgramString()
++    {
++        return ast.toString();
++    }
++
++    @Override
++    public Maybe<String> getLastRuleString()
++    {
++        return lastRuleString != null ? Maybe.from(lastRuleString) : Maybe.none();
++    }
++}
+diff --git a/src/main/java/model/CritterAction.java b/src/main/java/model/CritterAction.java
+new file mode 100644
+index 0000000..4896e35
+--- /dev/null
++++ b/src/main/java/model/CritterAction.java
+@@ -0,0 +1,699 @@
++package model;
++
++import ast.*;
++import parse.TokenType;
++
++public class CritterAction
++{
++    private World world;
++    private Critter critter;
++
++    public CritterAction (World world, Critter critter)
++    {
++        this.world = world;
++        this.critter = critter;
++    }
++
++    public boolean perform(TokenType action)
++    {
++        String name = action.toString();
++        switch(name)
++        {
++            case ("wait"):
++                return waitTurn();
++            case ("forward"):
++                return move(true);
++            case ("back"):
++                return move(false);
++            case ("left"):
++                return turn(true);
++            case ("right"):
++                return turn(false);
++            case ("eat"):
++                return eat();
++            case ("attack"):
++                return attack();
++            case ("grow"):
++                return grow();
++            case ("bud"):
++                return bud();
++            case ("mate"):
++                return mate();
++            default:
++                return false;
++        }
++
++    }
++
++    public boolean waitTurn()
++    {
++        critter.setMem(4, critter.getMemValue(4 ) + critter.getMemValue(3) * Constants.SOLAR_FLUX);
++        return true;
++    }
++    public boolean move (boolean direction){ //direction here refers to forwards or backwards
++
++        int r = critter.getRow();
++        int c = critter.getColumn();
++
++        if(critter.getMemValue(4) < critter.getMemValue(3) * 3) {
++            world.deadCritter(critter);
++            return false;
++        }
++
++        if(critter.getMemValue(4) == critter.getMemValue(3) * 3)
++        {
++            Tile[][] tiles = world.getTiles();
++            int row = -1;
++            int column = -1;
++            if(direction){
++                switch(critter.getDirection())
++                {
++                    case 0:
++                        column = c;
++                        row = r - 2;
++                    case 1:
++                        column = c + 1;
++                        row = r - 1;
++                    case 2:
++                        column = c + 1;
++                        row = r + 1;
++                    case 3:
++                        column = c;
++                        row = r + 2;
++                    case 4:
++                        column = c - 1;
++                        row = r + 1;
++                    case 5:
++                        column = c - 1;
++                        row = r - 1;
++                }
++            }
++
++            else
++            {
++                switch(critter.getDirection())
++                {
++                    case 0:
++                        column = c;
++                        row = r + 2;
++                    case 1:
++                        column = c - 1;
++                        row = r + 1;
++                    case 2:
++                        column = c - 1;
++                        row = r - 1;
++                    case 3:
++                        column = c;
++                        row = r - 2;
++                    case 4:
++                        column = c + 1;
++                        row = r - 1;
++                    case 5:
++                        column = c + 1;
++                        row = r + 1;
++                }
++            }
++            if(column < 0 || row < 0 || column >= tiles[0].length || row >= tiles.length
++                    || tiles[row][column].getIsRock() || tiles[row][column].getIsFood() || tiles[row][column].getIsCritter()){
++                world.deadCritter(critter);
++                return false;
++            }
++            else{
++                world.setCritterPosition(critter, column, row);
++                world.deadCritter(critter);
++                return true;
++            }
++        }
++
++        if(critter.getMemValue(4) > critter.getMemValue(3) * 3) {
++
++            Tile[][] tiles = world.getTiles();
++            int row = -1;
++            int column = -1;
++            if(direction){
++                switch(critter.getDirection()){
++                    case 0:
++                        column = c;
++                        row = r - 2;
++                    case 1:
++                        column = c + 1;
++                        row = r - 1;
++                    case 2:
++                        column = c + 1;
++                        row = r + 1;
++                    case 3:
++                        column = c;
++                        row = r + 2;
++                    case 4:
++                        column = c - 1;
++                        row = r + 1;
++                    case 5:
++                        column = c - 1;
++                        row = r - 1;
++                }
++                if(column < 0 || row < 0 || column >= tiles[0].length || row >= tiles.length
++                        || tiles[row][column].getIsRock() || tiles[row][column].getIsFood() || tiles[row][column].getIsCritter()){
++                    critter.setMem(4, critter.getMemValue(4) - critter.getMemValue(3) * Constants.MOVE_COST);
++                    return false;
++                }
++                else{
++                    critter.setMem(4, critter.getMemValue(4) - critter.getMemValue(3) * Constants.MOVE_COST);
++                    world.setCritterPosition(critter, column, row);
++                    return true;
++                }
++            }
++
++            else{
++                switch(critter.getDirection()){
++                    case 0:
++                        column = c;
++                        row = r + 2;
++                    case 1:
++                        column = c - 1;
++                        row = r + 1;
++                    case 2:
++                        column = c - 1;
++                        row = r - 1;
++                    case 3:
++                        column = c;
++                        row = r - 2;
++                    case 4:
++                        column = c + 1;
++                        row = r - 1;
++                    case 5:
++                        column = c + 1;
++                        row = r + 1;
++                }
++                if(column < 0 || row < 0 || column >= tiles[0].length || row >= tiles.length
++                        || tiles[row][column].getIsRock() || tiles[row][column].getIsFood() || tiles[row][column].getIsCritter()){
++                    critter.setMem(4, critter.getMemValue(4) - critter.getMemValue(3) * Constants.MOVE_COST);
++                    return false;
++                }
++                else{
++                    world.setCritterPosition(critter, column, row);
++                    critter.setMem(4, critter.getMemValue(4) - critter.getMemValue(3) * Constants.MOVE_COST);
++                    return true;
++                }
++            }
++        }
++        return false;
++    }
++    public boolean turn (boolean orientation){ //true is left, false is right
++
++        int newDir = critter.getDirection();
++
++        if(critter.getMemValue(4) < critter.getMemValue(3)){
++
++            world.deadCritter(critter);
++            return false;
++        }
++
++        else if(critter.getMemValue(4) == critter.getMemValue(3)){
++
++            if(orientation){
++                newDir += 5;
++                newDir %= 6;
++                critter.setDirection(newDir);
++            }
++            else{
++                newDir += 1;
++                newDir %= 6;
++                critter.setDirection(newDir);
++            }
++            world.deadCritter(critter);
++            return true;
++        }
++
++        else if(critter.getMemValue(4) > critter.getMemValue(3)){
++
++            if(orientation){
++                newDir += 5;
++                newDir %= 6;
++                critter.setDirection(newDir);
++            }
++            else{
++                newDir += 1;
++                newDir %= 6;
++                critter.setDirection(newDir);
++            }
++
++            return true;
++        }
++
++        return false;
++    }
++    public boolean eat (){
++
++        Tile[][] tiles = world.getTiles();
++        int r = critter.getRow();
++        int c = critter.getColumn();
++        switch(critter.getDirection()){
++            case 0:
++                c = c;
++                r = r + 2;
++            case 1:
++                c = c - 1;
++                r = r + 1;
++            case 2:
++                c = c - 1;
++                r = r - 1;
++            case 3:
++                c = c;
++                r = r - 2;
++            case 4:
++                c = c + 1;
++                r = r - 1;
++            case 5:
++                c = c + 1;
++                r = r + 1;
++        }
++
++        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && (tiles[r][c] != null && !tiles[r][c].getIsFood())) return false;
++
++
++        int food;
++        if(tiles[r][c] == null) food = 0;
++        else food = tiles[r][c].getNumFood();
++
++        int energyBefore = critter.getMemValue(4);
++
++        if(energyBefore + food <= critter.energyCapacity()){
++            critter.setMem(4, energyBefore + food);
++            tiles[r][c] = null;
++            return true;
++        }
++
++        else if(energyBefore + food > critter.energyCapacity()){
++
++            critter.setMem(4, critter.energyCapacity());
++            tiles[r][c] = new Tile(food - (critter.energyCapacity()) - energyBefore);
++            return true;
++        }
++
++        return false;
++    }
++    public boolean attack (){
++
++        int currEnergy = critter.getMemValue(4);
++        int energyUsed = critter.getMemValue(3) * Constants.ATTACK_COST;
++
++        critter.setMem(4, currEnergy - energyUsed);
++
++        if(critter.getMemValue(4) < 0){
++            world.deadCritter(critter);
++        }
++
++        Tile[][] tiles = world.getTiles();
++        int r = critter.getRow();
++        int c = critter.getColumn();
++        switch(critter.getDirection()){
++            case 0:
++                c = c;
++                r = r + 2;
++            case 1:
++                c = c - 1;
++                r = r + 1;
++            case 2:
++                c = c - 1;
++                r = r - 1;
++            case 3:
++                c = c;
++                r = r - 2;
++            case 4:
++                c = c + 1;
++                r = r - 1;
++            case 5:
++                c = c + 1;
++                r = r + 1;
++        }
++
++        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length || !tiles[r][c].getIsCritter()){
++            if(currEnergy == 0) world.deadCritter(critter);
++            return false;
++        }
++
++        Critter target = tiles[r][c].getCritter();
++        int size1 = critter.getMemValue(3);
++        int size2 = target.getMemValue(3);
++
++        int offensive = critter.getMemValue(2);
++        int defensive = critter.getMemValue(1);
++
++        double x = Constants.DAMAGE_INC * (size1 * offensive - size2 * defensive);
++        double Px = 1 / (1 + Math.exp(x));
++        int damageDone = (int) (Math.round( Constants.BASE_DAMAGE * size1 * Px));
++
++        int targetNewEnergy = target.getMemValue(4) - damageDone;
++        if(targetNewEnergy < 0) world.deadCritter(target);
++        else target.setMem(4, targetNewEnergy);
++
++        if(currEnergy == energyUsed){
++            world.deadCritter(critter);
++        }
++
++        return true;
++
++    }
++    public boolean grow (){
++        int cost = critter.getMemValue(3) * critter.complexity() * Constants.GROW_COST;
++        int currEnergy = critter.getMemValue(4);
++        if(currEnergy < cost){
++            world.deadCritter(critter);
++            return false;
++        }
++
++        critter.setMem(4, currEnergy - cost);
++        critter.setMem(3, critter.getMemValue(3) + 1);
++        return true;
++    }
++    public boolean bud ()
++    {
++        int newEnergy = critter.getMemValue(4) - critter.complexity() * Constants.BUD_COST;
++        if(newEnergy < 0){
++            world.deadCritter(critter);
++            return false;
++        }
++
++        critter.setMem(4, newEnergy);
++
++        Tile[][] tiles = world.getTiles();
++        int r = critter.getRow();
++        int c = critter.getColumn();
++        switch(critter.getDirection()){
++            case 0:
++                c = c;
++                r = r + 2;
++            case 1:
++                c = c - 1;
++                r = r + 1;
++            case 2:
++                c = c - 1;
++                r = r - 1;
++            case 3:
++                c = c;
++                r = r - 2;
++            case 4:
++                c = c + 1;
++                r = r - 1;
++            case 5:
++                c = c + 1;
++                r = r + 1;
++        }
++
++        if( c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && ( tiles[r][c] != null
++                && tiles[r][c].getIsRock() || tiles[r][c].getIsFood() || tiles[r][c].getIsCritter())){
++            if(newEnergy == 0) world.deadCritter(critter);
++            return false;
++        }
++
++        Program clonedAST = (Program) critter.getProgram().clone();
++
++        while(Math.random() < 1/4){
++            int selecter = (int) Math.random() * clonedAST.size();
++            Node mutatedNode = clonedAST.nodeAt(selecter);
++
++            int mutation = (int) (Math.random() * 6);
++
++            switch(mutation){
++                case 0:
++                    Mutation remove = MutationFactory.getRemove();
++                    remove.apply(clonedAST, mutatedNode);
++                case 1:
++                    Mutation swap = MutationFactory.getSwap();
++                    swap.apply(clonedAST, mutatedNode);
++                case 2:
++                    Mutation replace = MutationFactory.getReplace();
++                    replace.apply(clonedAST, mutatedNode);
++                case 3:
++                    Mutation transform = MutationFactory.getTransform();
++                    transform.apply(clonedAST, mutatedNode);
++                case 4:
++                    Mutation insert = MutationFactory.getInsert();
++                    insert.apply(clonedAST, mutatedNode);
++                case 5:
++                    Mutation duplicate = MutationFactory.getDuplicate();
++                    duplicate.apply(clonedAST, mutatedNode);
++            }
++        }
++
++        int[] mem = new int[critter.getMemory().length];
++        for(int i=0; i< mem.length; i++){
++            if(i==3) mem[3] = 1;
++            else if( i == 4) mem[4] = Constants.INITIAL_ENERGY;
++            else if(i == 6) mem[6] = 0;
++            else if(i >= 7) mem[i] = 0;
++            else {
++                mem[i] = critter.getMemValue(i);
++            }
++        }
++
++        world.addCritter(critter.getSpecies(), mem, clonedAST, r, c, critter.getDirection() );
++
++        if(newEnergy == 0) world.deadCritter(critter);
++        return true;
++
++    }
++    public boolean mate ()
++    {
++        int cost = critter.complexity() * Constants.MATE_COST;
++        int newEnergy = critter.getMemValue(4) - cost;
++        if(newEnergy < 0){
++            world.deadCritter(critter);
++            return false;
++        }
++        critter.setMem(4, newEnergy);
++
++        Tile[][] tiles = world.getTiles();
++        int r = critter.getRow();
++        int c = critter.getColumn();
++        switch(critter.getDirection()){
++            case 0:
++                c = c;
++                r = r + 2;
++            case 1:
++                c = c - 1;
++                r = r + 1;
++            case 2:
++                c = c - 1;
++                r = r - 1;
++            case 3:
++                c = c;
++                r = r - 2;
++            case 4:
++                c = c + 1;
++                r = r - 1;
++            case 5:
++                c = c + 1;
++                r = r + 1;
++        }
++
++        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length
++                || tiles[r][c].getIsRock() || tiles[r][c].getIsFood() || !tiles[r][c].getIsCritter()){
++            if(newEnergy == 0) world.deadCritter(critter);
++            return false;
++        }
++
++        Critter mate = tiles[r][c].getCritter();
++
++        boolean behindMate = true;
++
++        int r2 = r;
++        int c2 = c;
++
++        switch(critter.getDirection()){
++            case 0:
++                c2 = c2;
++                r2 = r2 + 2;
++            case 1:
++                c2 = c2 - 1;
++                r2 = r2 + 1;
++            case 2:
++                c2 = c2 - 1;
++                r2 = r2 - 1;
++            case 3:
++                c2 = c2;
++                r2 = r2 - 2;
++            case 4:
++                c2 = c2 + 1;
++                r2 = r2 - 1;
++            case 5:
++                c2 = c2 + 1;
++                r2 = r2 + 1;
++        }
++
++        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length
++                || tiles[r][c].getIsRock() || tiles[r][c].getIsFood() || tiles[r][c].getIsCritter()){
++            behindMate = false;
++        }
++
++        boolean behindSelf = true;
++
++        r = critter.getRow();
++        c = critter.getColumn();
++        switch( (critter.getDirection() + 3) % 6){
++            case 0:
++                c = c;
++                r = r + 2;
++            case 1:
++                c = c - 1;
++                r = r + 1;
++            case 2:
++                c = c - 1;
++                r = r - 1;
++            case 3:
++                c = c;
++                r = r - 2;
++            case 4:
++                c = c + 1;
++                r = r - 1;
++            case 5:
++                c = c + 1;
++                r = r + 1;
++        }
++
++        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length
++                || tiles[r][c].getIsRock() || tiles[r][c].getIsFood() || tiles[r][c].getIsCritter()){
++            behindSelf = false;
++        }
++
++        if( !behindMate && !behindSelf) return false;
++
++        if(mate.isMating() == false) {
++            critter.setMating(true);
++            return false;
++        }
++        else{
++            int matedRow;
++            int matedColumn;
++            int matedDirection;
++            if(behindMate && behindSelf){
++                if(Math.random() > 0.5) behindMate = false;
++                else behindSelf = false;
++            }
++            if(!behindMate && behindSelf){
++                matedRow = r;
++                matedColumn = c;
++                matedDirection = critter.getDirection();
++            }
++            else{
++                matedRow = r2;
++                matedColumn = c2;
++                matedDirection = mate.getDirection();
++            }
++
++            String newSpeciesName;
++            if(Math.random() > 0.5) newSpeciesName = critter.getSpecies();
++            else newSpeciesName = mate.getSpecies();
++
++            int size;
++            if(Math.random() < 0.5){
++                size = critter.getMemValue(0);
++            }
++            else{
++                size = mate.getMemValue(0);
++            }
++            int[] mem = new int[size];
++            for(int i=0; i< mem.length; i++){
++                if(i==3) mem[3] = 1;
++                else if( i == 4) mem[4] = Constants.INITIAL_ENERGY;
++                else if(i == 6) mem[6] = 0;
++                else if(i >= 7) mem[i] = 0;
++                else {
++                    if(Math.random() > 0.5) mem[i] = critter.getMemValue(i);
++                    else mem[i] = mate.getMemValue(i);
++                }
++            }
++
++            world.addCritter(newSpeciesName, mem, matedCritter(critter, mate), matedRow, matedColumn, matedDirection);
++
++            critter.setMating(false);
++            mate.setMating(false);
++        }
++
++        if(critter.getMemValue(4) == 0) world.deadCritter(critter);
++
++        return true;
++
++    }
++
++    public Program matedCritter(Critter mate1, Critter mate2){
++
++        double pickGenomeSize = Math.random();
++
++        Program mate1AST = mate1.getProgram();
++        Program mate2AST = mate2.getProgram();
++
++        Program newProgram = new ProgramImpl();
++        int size;
++        if(pickGenomeSize < 0.5){
++            size = mate1AST.size();
++        }
++        else{
++            size = mate2AST.size();
++        }
++
++        for(int i=0; i<size; i++){
++            if(i > mate1AST.size()) newProgram.getChildren().add(mate2AST.getChildren().get(i).clone());
++            else if(i > mate2AST.size()) newProgram.getChildren().add(mate1AST.getChildren().get(i).clone());
++            else {
++                if(Math.random() > 0.5) newProgram.getChildren().add(mate1AST.getChildren().get(i).clone());
++                else newProgram.getChildren().add(mate2AST.getChildren().get(i).clone());
++            }
++        }
++
++        return newProgram;
++    }
++
++
++    public boolean serve (int value)
++    {
++        int energySpent = critter.getMemValue(3) + value;
++
++        if(energySpent > critter.getMemValue(4)) {
++            world.deadCritter(critter);
++            return false;
++        }
++
++        critter.setMem(4, critter.getMemValue(4) - energySpent);
++
++        Tile[][] tiles = world.getTiles();
++        int r = critter.getRow();
++        int c = critter.getColumn();
++        switch(critter.getDirection()){
++            case 0:
++                c = c;
++                r = r + 2;
++            case 1:
++                c = c - 1;
++                r = r + 1;
++            case 2:
++                c = c - 1;
++                r = r - 1;
++            case 3:
++                c = c;
++                r = r - 2;
++            case 4:
++                c = c + 1;
++                r = r - 1;
++            case 5:
++                c = c + 1;
++                r = r + 1;
++        }
++
++        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length
++                || tiles[r][c].getIsRock() || tiles[r][c].getIsCritter()){
++            if(critter.getMemValue(4) == 0) world.deadCritter(critter);
++            return false;
++        }
++
++        tiles[r][c] = new Tile(tiles[r][c].getNumFood() + value);
++
++        if(critter.getMemValue(4) == 0){
++            world.deadCritter(critter);
++        }
++
++        return true;
++    }
++
++
++}
+diff --git a/src/main/java/model/Interpreter.java b/src/main/java/model/Interpreter.java
+new file mode 100644
+index 0000000..ccda85b
+--- /dev/null
++++ b/src/main/java/model/Interpreter.java
+@@ -0,0 +1,486 @@
++package model;
++
++import ast.*;
++import ast.Number;
++import org.eclipse.jetty.http.HttpTokens;
++import parse.TokenType;
++
++import java.util.ArrayList;
++import java.util.LinkedList;
++import java.util.Random;
++
++public class Interpreter
++{
++    private World world;
++    private Critter critter;
++    private int numRulesRun;
++
++    public Interpreter(World world, Critter critter)
++    {
++        this.world = world;
++        this.critter = critter;
++        this.numRulesRun = 0;
++    }
++
++    public boolean interpret()
++    {
++        while(numRulesRun < Constants.MAX_RULES_PER_TURN)
++        {
++            if (interpretProgram(critter.getProgram()) == 0){
++                System.out.println(critter.getLastRuleString());
++                return true;
++            }
++        }
++
++        CritterAction critterAction = new CritterAction(world, critter);
++        critterAction.perform(TokenType.WAIT);
++        return false;
++    }
++    public int interpretProgram(Program program)
++    {
++        Rule lastRule = null;
++        for(Node rule : program.getChildren())
++        {
++            int i = interpretRule(rule);
++            if(i == 0)
++            {
++                lastRule = (Rule) rule;
++                critter.setLastRuleString(lastRule.toString());
++                return 0;
++            }
++            else if(i == 1)
++            {
++                lastRule = (Rule) rule;
++                critter.setLastRuleString(lastRule.toString());
++            }
++            numRulesRun ++;
++        }
++
++        if(lastRule == null)
++        {
++            return -1;
++        }
++        else return 1;
++    }
++    public int interpretRule(Node node)
++    {
++        Rule rule = (Rule) node;
++        boolean updated = false;
++        if(interpretCondition(rule.getCondition()))
++        {
++            critter.setLastRuleString(node.toString());
++            for(Node child : rule.getCommand().getChildren())
++            {
++                if(child.getClass() == Update.class)
++                {
++                    interpretUpdate(child);
++                    System.out.println(critter.getSpecies() + ": " + child.toString());
++                    updated = true;
++                }
++                else if(child.getClass() == Action.class)
++                {
++                    System.out.println(critter.getSpecies() + ":" + child.toString());
++                    if(interpretAction(child)) return 0;
++                    else System.out.println("failed action bozo");
++                }
++            }
++        }
++        if(updated) return 1;
++        else return -1;
++    }
++    public boolean interpretUpdate(Node update)
++    {
++        Update curr = (Update) update;
++        int memType = interpretExpression(curr.getMemType().getExpr());
++        int updateValue = interpretExpression(curr.getExpr());
++
++        if(memType >= critter.getMemValue(0)){
++            System.out.println("not valid mem value bozo");
++            return false;
++        }
++        critter.setMem(memType, updateValue);
++
++
++        return true;
++    }
++    public boolean interpretAction(Node node)
++    {
++        Action action = (Action) node;
++        TokenType tt = action.getName();
++        CritterAction critterAction = new CritterAction(world, critter);
++
++        if(tt == TokenType.SERVE){
++            return critterAction.serve(interpretExpression(action.getExpr()));
++        }
++        else{
++            return critterAction.perform(tt);
++        }
++    }
++    public boolean interpretCondition(Node condition){
++
++        if(condition.getClass() == Relation.class){
++            return interpretRelation(condition);
++        }
++
++        BinaryCondition bc = (BinaryCondition) condition;
++        boolean left = false;
++        boolean right = false;
++        BinaryCondition.Operator op = bc.getOp();
++        if(bc.getLeft().getClass() == BinaryCondition.class){
++            left = interpretCondition(bc.getLeft());
++        }
++        else if(bc.getLeft().getClass() == Relation.class){
++            left = interpretRelation(bc.getLeft());
++        }
++        if(bc.getRight().getClass() == BinaryCondition.class){
++            right = interpretCondition(bc.getRight());
++        }
++        else if(bc.getRight().getClass() == Relation.class){
++            right = interpretRelation(bc.getRight());
++        }
++
++        if(op == BinaryCondition.Operator.AND){
++            return left && right;
++        }
++        else return left || right;
++
++
++    }
++
++    public boolean interpretRelation(Node node){
++        Relation relation = (Relation) node;
++        int left = interpretExpression(relation.getLeft());
++        int right = interpretExpression(relation.getRight());
++        String rel = relation.getOperator().toString();
++
++        switch(rel){
++            case("<"):
++                return (left < right);
++            case("<="):
++                return (left <= right);
++            case("="):
++                return (left == right);
++            case(">="):
++                return (left >= right);
++            case(">"):
++                return (left > right);
++            case("!="):
++                return (left != right);
++            default:
++                System.out.println(rel + " is not a valid relation operator");
++                return false;
++        }
++    }
++
++    public int interpretExpression(Node node){
++        Expr expr = (Expr) node;
++        if(expr.getClass() == BinaryOp.class){
++            BinaryOp binOp = (BinaryOp) expr;
++            int left = interpretExpression((binOp.getLeft()));
++            int right = interpretExpression(binOp.getRight());
++            String op = binOp.getOp().toString();
++
++            switch(op){
++                case("+"):
++                    return left + right;
++                case("-"):
++                    return left - right;
++                case("*"):
++                    return left * right;
++                case("/"):
++                    return (left / right);
++                case("mod"):
++                    return (left % right);
++                default:
++                    System.out.println(op + " is not a valid binary operator stoopid");
++                    return -1;
++
++            }
++        }
++
++        else if(expr.getClass() == NegativeExpr.class){
++            NegativeExpr negged = (NegativeExpr) expr;
++            return -1 * interpretExpression(negged.getRight());
++        }
++
++        else if(expr.getClass() == Number.class){
++            Number num = (Number) expr;
++            return num.getNum();
++        }
++
++        else if(expr.getClass() == Mem.class){
++            Mem mem = (Mem) expr;
++            return critter.getMemValue(interpretExpression(mem.getExpr()));
++        }
++
++        else if(expr.getClass() == AheadSensor.class){
++            AheadSensor as = (AheadSensor) expr;
++            return interpretAheadSensor(interpretExpression(as.getExpr()));
++        }
++        else if(expr.getClass() == RandomSensor.class){
++            RandomSensor rs = (RandomSensor) expr;
++            return (int) (Math.random() * interpretExpression(rs.getExpr()));
++        }
++
++        return 0;
++    }
++
++    // TODO account for out of bounds indices
++    public int interpretNearbySensor(int dir)
++    {
++        dir = Math.abs((dir + critter.getDirection())) % 6;
++        if (dir == 0)
++        {
++            int info = world.getTerrainInfo(critter.getColumn(), critter.getRow() - 2);
++            if(info == 0) return 0;
++            else if(info < -1) return info;
++            else if(info == -1) return -1;
++            else
++            {
++                Tile[][] tiles = world.getTiles();
++                Critter crit = tiles[critter.getColumn()][critter.getRow() + 2].getCritter();
++                return crit.getMemValue(3)*1000 + crit.getMemValue(6)*10 +  critter.getDirection();
++            }
++        }
++        else if (dir == 1)
++        {
++            int info = world.getTerrainInfo(critter.getColumn() + 1, critter.getRow() - 1);
++            if(info == 0) return 0;
++            else if(info < -1) return info;
++            else if(info == -1) return -1;
++            else
++            {
++                Tile[][] tiles = world.getTiles();
++                Critter crit = tiles[critter.getColumn()][critter.getRow() + 2].getCritter();
++                return crit.getMemValue(3)*1000 + crit.getMemValue(6)*10 +  crit.getDirection();
++
++            }
++        }
++        else if (dir == 2)
++        {
++            int info = world.getTerrainInfo(critter.getColumn() + 1, critter.getRow() + 1);
++            if(info == 0) return 0;
++            else if(info < -1) return info;
++            else if(info == -1) return -1;
++            else{
++                Tile[][] tiles = world.getTiles();
++                Critter crit = tiles[critter.getColumn()][critter.getRow() + 2].getCritter();
++                return crit.getMemValue(3)*1000 + crit.getMemValue(6)*10 +  crit.getDirection();
++
++            }
++        }
++        else if (dir == 3)
++        {
++            int info = world.getTerrainInfo(critter.getColumn(), critter.getRow() + 2);
++            if(info == 0) return 0;
++            else if(info < -1) return info;
++            else if(info == -1) return -1;
++            else{
++                Tile[][] tiles = world.getTiles();
++                Critter crit = tiles[critter.getColumn()][critter.getRow() + 2].getCritter();
++                return crit.getMemValue(3)*1000 + crit.getMemValue(6)*10 +  crit.getDirection();
++
++            }
++        }
++        else if (dir == 4)
++        {
++            int info = world.getTerrainInfo(critter.getColumn() - 1, critter.getRow() + 1);
++            if(info == 0) return 0;
++            else if(info < -1) return info;
++            else if(info == -1) return -1;
++            else{
++                Tile[][] tiles = world.getTiles();
++                Critter crit = tiles[critter.getColumn()][critter.getRow() + 2].getCritter();
++                return crit.getMemValue(3)*1000 + crit.getMemValue(6)*10 +  crit.getDirection();
++
++            }
++        }
++        else if (dir == 5)
++        {
++            int info = world.getTerrainInfo(critter.getColumn() - 1, critter.getRow() - 1);
++            if(info == 0) return 0;
++            else if(info < -1) return info;
++            else if(info == -1) return -1;
++            else
++            {
++                Tile[][] tiles = world.getTiles();
++                Critter crit = tiles[critter.getColumn()][critter.getRow() + 2].getCritter();
++                return crit.getMemValue(3)*1000 + crit.getMemValue(6)*10 +  crit.getDirection();
++
++            }
++        }
++        else
++        {
++            return 0;
++        }
++    }
++
++    // TODO account for out of bounds indices
++    public int interpretAheadSensor(int dist)
++    {
++        dist = Math.max(dist, 0);
++        int dir = critter.getDirection();
++        int row = critter.getRow();
++        int column = critter.getColumn();
++        int info;
++        if (dir == 0)
++        {
++            row -= dist * 2;
++            info = world.getTerrainInfo(column, row);
++        }
++        else if (dir == 1)
++        {
++            row -= dist;
++            column += dist;
++            info = world.getTerrainInfo(column, row);
++        }
++        else if (dir == 2)
++        {
++            row += dist;
++            column += dist;
++            info = world.getTerrainInfo(column, row);
++        }
++        else if (dir == 3)
++        {
++            row += dist * 2;
++            info = world.getTerrainInfo(column, row);
++        }
++        else if (dir == 4)
++        {
++            row += dist;
++            column -= dist;
++            info = world.getTerrainInfo(column, row);
++        }
++        else
++        {
++            row -= dist;
++            column -= dist;
++            info = world.getTerrainInfo(column, row);
++        }
++
++        if (info <= 0)
++        {
++            return info;
++        }
++        else
++        {
++            Tile[][] tiles = world.getTiles();
++            Critter target = tiles[row][column].getCritter();
++            return target.getMemValue(3) * 1000 + target.getMemValue(6) * 10 + target.getDirection();
++        }
++    }
++
++    public int interpretSmellSensor()
++    {
++        Tile[][] tiles = world.getTiles();
++        int row = critter.getRow();
++        int column = critter.getColumn();
++        int dir = critter.getDirection();
++        LinkedList<int[]> tileSearch = new LinkedList<int[]>();
++        tileSearch.add(new int[]{row - 2, column});
++        tileSearch.add(new int[]{row - 1, column + 1});
++        tileSearch.add(new int[]{row + 1, column + 1});
++        tileSearch.add(new int[]{row + 2, column});
++        tileSearch.add(new int[]{row + 1, column - 1});
++        tileSearch.add(new int[]{row - 1, column - 1});
++        int[] foodCoordinates = findNearestFood(tiles, tileSearch);
++        int cx = column;
++        int cy = tiles[0].length - 1 - row;
++        int fx = foodCoordinates[1];
++        int fy = foodCoordinates[0];
++        int dist = Math.max(Math.abs(fx - cx), Math.abs(fx - cx + fy - cy) / 2);
++        dist = Math.max(dist, Math.abs(fx - cx - fy + cy));
++        if (foodCoordinates[0] == -1 || dist > Constants.MAX_SMELL_DISTANCE)
++        {
++            return 1000000;
++        }
++
++        // TODO fix int division
++        // based off assumption row is first
++        int tanned = (int) Math.atan((double) (fx - cx) / (double) (fy - cy));
++        if( (foodCoordinates[1] - row) < 0)
++        {
++            tanned += 180;
++        }
++
++        int dirOfFood = critter.getDirection();
++        if(tanned >= 0 && tanned < 60)
++        {
++            dirOfFood = 1 - dirOfFood + 6;
++        }
++        else if(tanned >= 60 && tanned < 120)
++        {
++            dirOfFood = 0 - dirOfFood + 6;
++        }
++        else if(tanned >= 120 && tanned < 180)
++        {
++            dirOfFood = 5 - dirOfFood + 6;
++        }
++        else if(tanned >= 180 && tanned < 240)
++        {
++            dirOfFood = 4 - dirOfFood + 6;
++        }
++        else if(tanned >= 240 && tanned < 300)
++        {
++            dirOfFood = 3 - dirOfFood + 6;
++        }
++        else if(tanned >= 300 && tanned < 360)
++        {
++            dirOfFood = 2 - dirOfFood + 6;
++        }
++        dirOfFood %= 6;
++        return 1000 * dist + dirOfFood;
++    }
++
++    public int[] findNearestFood(Tile[][] tiles, LinkedList<int[]> tileSearch)
++    {
++        while (tileSearch.peek() != null)
++        {
++            int[] coordinates = tileSearch.poll();
++            if (tiles[coordinates[0]][coordinates[1]].getIsFood())
++            {
++                return coordinates;
++            }
++            int rowSize = tiles.length;
++            int columnSize = tiles[0].length;
++            int row = coordinates[0];
++            int column = coordinates[1];
++            if (row - 2 >= 0)
++            {
++                tileSearch.add(new int[]{row - 2, column});
++            }
++            if (row - 1 >= 0 && column + 1 < columnSize)
++            {
++                tileSearch.add(new int[]{row - 1, column + 1});
++            }
++            if (row + 1 < rowSize && column + 1 < columnSize)
++            {
++                tileSearch.add(new int[]{row + 1, column + 1});
++            }
++            if (row + 1 < rowSize)
++            {
++                tileSearch.add(new int[]{row + 2, column});
++            }
++            if (row + 1 < rowSize && column - 1 >= 0)
++            {
++                tileSearch.add(new int[]{row + 1, column - 1});
++            }
++            if (row - 1 >= 0 && column - 1 >= 0)
++            {
++                tileSearch.add(new int[]{row - 1, column - 1});
++            }
++        }
++        return new int[]{-1, -1};
++    }
++
++    public int interpretRandomSensor(RandomSensor rs, int n)
++    {
++        return n < 2 ? 0 : (int) (Math.random() * n);
++    }
++
++
++    public void setMem(int memIndex, int changeNumber)
++    {
++        critter.setMem(memIndex, changeNumber);
++    }
++}
+diff --git a/src/main/java/model/ReadOnlyCritter.java b/src/main/java/model/ReadOnlyCritter.java
+new file mode 100644
+index 0000000..a291032
+--- /dev/null
++++ b/src/main/java/model/ReadOnlyCritter.java
+@@ -0,0 +1,24 @@
++package model;
++
++import cms.util.maybe.Maybe;
++
++public interface ReadOnlyCritter {
++    /** @return critter species. */
++    String getSpecies();
++
++    /**
++     * Hint: you should consider making a defensive copy of the array.
++     *
++     * @return an array representation of critter's memory.
++     */
++    int[] getMemory();
++
++    /** @return current program string of the critter. */
++    String getProgramString();
++
++    /**
++     * @return last rule executed by the critter on its previous turn, or {@code Maybe.none()} if it has not
++     *     executed any.
++     */
++    Maybe<String> getLastRuleString();
++}
+diff --git a/src/main/java/model/ReadOnlyWorld.java b/src/main/java/model/ReadOnlyWorld.java
+new file mode 100644
+index 0000000..4588f5e
+--- /dev/null
++++ b/src/main/java/model/ReadOnlyWorld.java
+@@ -0,0 +1,27 @@
++package model;
++
++import cms.util.maybe.Maybe;
++
++public interface ReadOnlyWorld
++{
++    /** @return number of steps */
++    int getSteps();
++
++    /** @return number of alive critters. */
++    int getNumberOfAliveCritters();
++
++    /**
++     * @param c column id.
++     * @param r row id.
++     * @return the critter at the specified hex.
++     */
++    Maybe<ReadOnlyCritter> getReadOnlyCritter(int c, int r);
++
++    /**
++     * @param c column id.
++     * @param r row id.
++     * @return 0 if the cell is empty. -1 if it is rock, -(X+1) if it is X food, X+1 if it contains a critter facing 
++     *         in direction X. Treat out-of-bound or invalid hex as rock.
++     */
++    int getTerrainInfo(int c, int r);
++}
+diff --git a/src/main/java/model/Tile.java b/src/main/java/model/Tile.java
+new file mode 100644
+index 0000000..8c584e4
+--- /dev/null
++++ b/src/main/java/model/Tile.java
+@@ -0,0 +1,68 @@
++package model;
++
++public class Tile {
++
++    private boolean isRock;
++    private boolean isFood;
++    private boolean isCritter;
++
++    private int numFood = 0;
++    private Critter critter;
++
++    Tile()
++    {
++        isRock = true;
++        this.isFood = false;
++        this.isCritter = false;
++    }
++
++    Tile(int numFood)
++    {
++        this.isFood = true;
++        this.isRock = false;
++        this.isCritter = false;
++        this.numFood = numFood;
++    }
++
++    Tile(Critter critter)
++    {
++        this.isCritter = true;
++        this.isFood = false;
++        this.isRock = false;
++        this.critter = critter;
++    }
++
++    Tile(Boolean bool)
++    {
++        this.isCritter = false;
++        this.isFood = false;
++        this.isRock = false;
++    }
++
++    public boolean getIsRock()
++    {
++        return isRock;
++    }
++
++    public boolean getIsFood()
++    {
++        return numFood > 0 ? true : false;
++    }
++
++    public boolean getIsCritter()
++    {
++        return isCritter;
++    }
++
++    public int getNumFood()
++    {
++        return numFood;
++    }
++
++    public Critter getCritter()
++    {
++        return critter;
++    }
++
++
++}
+diff --git a/src/main/java/model/World.java b/src/main/java/model/World.java
+new file mode 100644
+index 0000000..90eb109
+--- /dev/null
++++ b/src/main/java/model/World.java
+@@ -0,0 +1,318 @@
++package model;
++
++import ast.Mutation;
++import ast.MutationFactory;
++import ast.Node;
++import ast.Program;
++import cms.util.maybe.Maybe;
++import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;
++
++import java.io.PrintStream;
++import java.util.ArrayList;
++
++public class World extends ControlOnlyWorld implements ReadOnlyWorld
++{
++    private int numRows;
++    private int numColumns;
++    private Tile[][] tiles;
++    private int numSteps;
++    private ArrayList<Critter> critters;
++    private boolean enableManna;
++    private boolean enableForcedMutation;
++
++    public World()
++    {
++        this.numRows = Constants.HEIGHT;
++        this.numColumns = Constants.WIDTH;
++        this.tiles = new Tile[numRows][numColumns];
++        this.critters = new ArrayList<>();
++    }
++
++    public World(int width, int height, boolean enableManna, boolean enableForcedMutation)
++    {
++        this.numRows = height;
++        this.numColumns = width;
++        this.tiles = new Tile[numRows][numColumns];
++        this.critters = new ArrayList<>();
++        this.enableManna = enableManna;
++        this.enableForcedMutation = enableForcedMutation;
++    }
++
++    public Tile[][] getTiles()
++    {
++        return tiles;
++    }
++
++//    public int getNumRows()
++//    {
++//        return numRows;
++//    }
++//
++//    public int getNumColumns()
++//    {
++//        return numColumns;
++//    }
++
++    @Override
++    public boolean addCritter(String species, int[] mem, Program ast)
++    {
++        // TODO fix random coordinates ((x + y) % 2 == 0)
++//        System.out.println(numRows + " " + numColumns);
++        boolean flag = false;
++        int count = 0;
++        while (!flag && count < numRows * numColumns)
++        {
++            int row = (int)(Math.random() * numRows);
++            int column = (tiles.length - 1 - row) % 2 == 0 ? (int) (Math.random() * ((numColumns + 1) / 2)) * 2:
++                    (int) (Math.random() * (numColumns / 2)) * 2 + 1;
++//            if ((tiles.length - 1 - row) % 2 == 0)
++//            {
++//                System.out.println("even");
++//            }
++//            else
++//            {
++//                System.out.println("odd");
++//            }
++//            System.out.println((tiles.length - 1 - row) + " " + column);
++//            System.out.println();
++            flag = addCritter(species, mem, ast, row, column, (int) (Math.random() * 6));
++            count++;
++        }
++        return flag;
++    }
++
++    @Override
++    public boolean addCritter(String species, int[] mem, Program ast, int row, int column, int dir)
++    {
++        row = tiles.length - 1 - row;
++        if(tiles[row][column] != null)
++        {
++            Tile curr = tiles[row][column];
++            if(curr.getIsCritter() || curr.getIsFood() || curr.getIsRock()) return false;
++        }
++        tiles[row][column] = new Tile(new Critter(species, ast, mem, row, column, dir));
++        critters.add(tiles[row][column].getCritter());
++        return true;
++    }
++
++
++    @Override
++    public boolean addRock(int row, int column)
++    {
++        row = tiles.length - 1 - row;
++        if(tiles[row][column] != null)
++        {
++            Tile curr = tiles[row][column];
++            if(curr.getIsCritter() || curr.getIsFood() || curr.getIsRock()) return false;
++        }
++        tiles[row][column] = new Tile();
++        return true;
++    }
++
++    @Override
++    public boolean addFood(int row, int column, int amount)
++    {
++        row = tiles.length - 1 - row;
++        if(tiles[row][column] != null)
++        {
++            Tile curr = tiles[row][column];
++            if(curr.getIsCritter() || curr.getIsFood() || curr.getIsRock()) return false;
++        }
++        tiles[row][column] = new Tile(amount);
++        return true;
++    }
++
++    @Override
++    public void advanceTimeStep()
++    {
++        if(critters.size() == 0) System.out.println("all critters dead at timestep :" + numSteps);
++
++        for (int i = 0; i < critters.size(); i++)
++        {
++            Critter critter = critters.get(i);
++            if(critter.isJustCreated())
++            {
++                critter.setJustcreated(false);
++                continue;
++            }
++            Interpreter interpreter = new Interpreter(this, critter);
++            interpreter.interpretProgram(critter.getProgram());
++            if (!critters.contains(critter))
++            {
++                i--;
++            }
++        }
++        for(Critter critter: critters)
++        {
++            critter.setMating(false);
++        }
++        numSteps++;
++    }
++
++    @Override
++    public void printWorld(PrintStream out)
++    {
++        for (int i = 0; i < tiles.length; i++)
++        {
++            for (int j = (tiles.length - 1 - i) % 2; j < tiles[i].length; j += 2)
++            {
++                if (j == 1)
++                {
++                    System.out.print(" ");
++                }
++
++                if (tiles[i][j] == null)
++                {
++                    System.out.print("-");
++                }
++                else if (tiles[i][j].getIsRock())
++                {
++                    System.out.print("#");
++                }
++                else if (tiles[i][j].getIsCritter())
++                {
++                    System.out.print(tiles[i][j].getCritter().getDirection());
++                }
++                else if (tiles[i][j].getIsFood())
++                {
++                    System.out.print("F");
++                }
++
++                if (j < tiles[i].length - 1)
++                {
++                    System.out.print(" ");
++                }
++            }
++            System.out.println();
++        }
++    }
++
++    @Override
++    public int getSteps()
++    {
++        return numSteps;
++    }
++
++    @Override
++    public int getNumberOfAliveCritters()
++    {
++        return critters.size();
++    }
++
++    @Override
++    public Maybe<ReadOnlyCritter> getReadOnlyCritter(int c, int r)
++    {
++        if(c >= numColumns || c < 0 || r >= numRows || r < 0 || tiles[r][c] == null || !tiles[r][c].getIsCritter()) return Maybe.none();
++
++        return Maybe.some(tiles[r][c].getCritter());
++    }
++
++    @Override
++    public int getTerrainInfo(int c, int r)
++    {
++        if(c >= numColumns || c < 0 || r >= numRows || r < 0) return -1; // out of bounds indices should be treated as a rock
++        if(tiles[r][c] == null) return 0;
++        if(tiles[r][c].getIsRock()) return Constants.ROCK_VALUE;
++        else if(tiles[r][c].getIsFood()) return (tiles[r][c].getNumFood() + 1) * -1;
++        else if(tiles[r][c].getIsCritter()) return tiles[r][c].getCritter().getDirection() + 1;
++        return 0;
++    }
++
++    public boolean deadCritter(Critter critter)
++    {
++        int row = critter.getRow();
++        int column = critter.getColumn();
++        if( !tiles[row][column].getCritter().equals(critter) ) return false;
++
++        System.out.println(critter.getSpecies() + " died at time step: " + numSteps);
++        tiles[row][column] = new Tile(critter.getMemValue(3) * Constants.FOOD_PER_SIZE);
++        critters.remove(critter);
++
++        return true;
++    }
++
++    public void setCritterPosition(Critter critter, int r, int c){
++        tiles[critter.getColumn()][critter.getRow()] = null;
++        tiles[r][c] = new Tile(critter);
++        critter.setPosition(r, c);
++    }
++
++    @Override
++    public void addManna()
++    {
++        if(critters.size() == 0){
++            return;
++        }
++
++        if(Math.random() > ((double) (1) / (double) (getNumberOfAliveCritters()))) return;
++
++        int numTiles = numRows * numColumns;
++
++        for(int i=0; i < ( Constants.MANNA_COUNT * numTiles / 1000); i++){
++
++            int r = (int)(Math.random() * numRows);
++            int c = (tiles.length - 1 - r) % 2 == 0 ? (int) (Math.random() * ((numColumns + 1) / 2)) * 2:
++                    (int) (Math.random() * (numColumns / 2)) * 2 + 1;
++
++            if (tiles[r][c] == null)
++            {
++                tiles[r][c] = new Tile(Constants.MANNA_AMOUNT);
++            }
++
++            else
++            {
++                while (tiles[r][c].getIsRock() || tiles[r][c].getIsCritter())
++                {
++                    r = (int) (Math.random() * numRows);
++                    c = (tiles.length - 1 - r) % 2 == 0 ? (int) (Math.random() * ((numColumns + 1) / 2)) * 2 :
++                            (int) (Math.random() * (numColumns / 2)) * 2 + 1;
++                    if (tiles[r][c] == null)
++                    {
++                        tiles[r][c] = new Tile(Constants.MANNA_AMOUNT);
++                        break;
++                    }
++                }
++                if (tiles[r][c] != null)
++                {
++                    tiles[r][c] = new Tile(tiles[r][c].getNumFood() + Constants.MANNA_AMOUNT);
++                }
++            }
++        }
++
++    }
++
++    @Override
++    public void forcedMutate()
++    {
++        for(Critter critter : critters)
++        {
++            Program ast = critter.getProgram();
++            int selector = (int) Math.random() * ast.size();
++            Node mutatedNode = ast.nodeAt(selector);
++
++            int mutation = (int) (Math.random() * 6);
++
++            switch(mutation){
++                case 0:
++                    Mutation remove = MutationFactory.getRemove();
++                    remove.apply(ast, mutatedNode);
++                case 1:
++                    Mutation swap = MutationFactory.getSwap();
++                    swap.apply(ast, mutatedNode);
++                case 2:
++                    Mutation replace = MutationFactory.getReplace();
++                    replace.apply(ast, mutatedNode);
++                case 3:
++                    Mutation transform = MutationFactory.getTransform();
++                    transform.apply(ast, mutatedNode);
++                case 4:
++                    Mutation insert = MutationFactory.getInsert();
++                    insert.apply(ast, mutatedNode);
++                case 5:
++                    Mutation duplicate = MutationFactory.getDuplicate();
++                    duplicate.apply(ast, mutatedNode);
++            }
++        }
++
++    }
++}
+diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
+index 53e4276..bbdf120 100644
+--- a/src/main/java/parse/ParserImpl.java
++++ b/src/main/java/parse/ParserImpl.java
+@@ -8,7 +8,6 @@ import java.io.Reader;
+ 
+ class ParserImpl implements Parser
+ {
+-
+     @Override
+     public Program parse(Reader r) throws SyntaxError
+     {
+@@ -36,7 +35,7 @@ class ParserImpl implements Parser
+         }
+         if (ret.getChildren().size() < 1)
+         {
+-            throw new UnsupportedOperationException();
++            throw new SyntaxError(t.lineNumber(), "invalid input program");
+         }
+         return ret;
+     }
+@@ -77,7 +76,7 @@ class ParserImpl implements Parser
+         }
+         if (command.getChildren().size() < 1)
+         {
+-            throw new UnsupportedOperationException();
++            throw new SyntaxError(t.lineNumber(), "invalid input program");
+         }
+         return command;
+     }
+@@ -110,13 +109,13 @@ class ParserImpl implements Parser
+     public static Action parseAction(Tokenizer t) throws SyntaxError
+     {
+ //        System.out.println("parseAction");
+-        if(t.peek().getType().category() != TokenCategory.ACTION) throw new UnsupportedOperationException();
++        if(t.peek().getType().category() != TokenCategory.ACTION) throw new SyntaxError(t.lineNumber(), "invalid input program");
+         TokenType actionName = t.next().getType();
+         if(actionName == TokenType.SERVE)
+         {
+-            consume(t, TokenType.LBRACE);
++            consume(t, TokenType.LBRACKET);
+             Expr deezN = parseExpression(t);
+-            consume(t, TokenType.RBRACE);
++            consume(t, TokenType.RBRACKET);
+             Action ret = new Action(actionName, deezN);
+             deezN.setParent(ret);
+             return ret;
+@@ -169,7 +168,7 @@ class ParserImpl implements Parser
+         else
+         {
+             Expr left = parseExpression(t);
+-            if(t.peek().getType().category() != TokenCategory.RELOP) throw new UnsupportedOperationException( );
++            if(t.peek().getType().category() != TokenCategory.RELOP) throw new SyntaxError(t.lineNumber(), "invalid input program");
+             TokenType rel = t.next().getType();
+             Expr right = parseExpression(t);
+             Condition ret = new Relation(left, rel, right);
+@@ -243,7 +242,7 @@ class ParserImpl implements Parser
+         else if (t.peek().getType() == TokenType.MINUS)
+         {
+             t.next();
+-            return new NegativeExpr(new Negative(), parseFactor(t));
++            return new NegativeExpr(parseFactor(t));
+         }
+         else if (t.peek().isSensor())
+         {
+@@ -251,7 +250,7 @@ class ParserImpl implements Parser
+         }
+         else
+         {
+-            throw new UnsupportedOperationException();
++            throw new SyntaxError(t.lineNumber(), "invalid input program");
+         }
+     }
+ 
+@@ -295,7 +294,7 @@ class ParserImpl implements Parser
+         }
+         else
+         {
+-            throw new UnsupportedOperationException();
++            throw new SyntaxError(t.lineNumber(), "invalid input program");
+         }
+     }
+ 
+@@ -309,7 +308,7 @@ class ParserImpl implements Parser
+         Token temp = t.next();
+         if(temp.getType() != tt)
+         {
+-            throw new UnsupportedOperationException();
++            throw new SyntaxError(t.lineNumber(), "invalid input program");
+         }
+     }
+ }
+diff --git a/src/main/java/parse/TokenType.java b/src/main/java/parse/TokenType.java
+index b2c6ffd..d652443 100644
+--- a/src/main/java/parse/TokenType.java
++++ b/src/main/java/parse/TokenType.java
+@@ -6,7 +6,8 @@ import java.util.Map;
+ 
+ /** An instance represents a Token with a category and a string representation.
+  */
+-public enum TokenType {
++public enum TokenType
++{
+     MEM(TokenCategory.OTHER, "mem"),
+     WAIT(TokenCategory.ACTION, "wait"),
+     FORWARD(TokenCategory.ACTION, "forward"),
+@@ -60,7 +61,8 @@ public enum TokenType {
+     private static final Map<String, TokenType> stringToTypeMap;
+ 
+     // static initializer to initialize the values of stringToTypeMap
+-    static {
++    static
++    {
+         final Map<String, TokenType> temp = new HashMap<>();
+         for (TokenType t : TokenType.values()) {
+             temp.put(t.stringRep, t);
+diff --git a/src/main/java/parse/Tokenizer.java b/src/main/java/parse/Tokenizer.java
+index 4f0b221..470de93 100644
+--- a/src/main/java/parse/Tokenizer.java
++++ b/src/main/java/parse/Tokenizer.java
+@@ -8,6 +8,7 @@ import java.util.Queue;
+ 
+ import easyIO.EOF;
+ import easyIO.Scanner;
++import easyIO.UnexpectedInput;
+ 
+ /**
+  * A Tokenizer turns a Reader into a stream of tokens that can be iterated over
+@@ -79,11 +80,16 @@ public class Tokenizer implements Iterator<Token> {
+      * @throws TokenizerIOException if an IOException was thrown while trying
+      *                              to read from the source Reader
+      */
+-    public Token peek() {
+-        if (tokens.isEmpty()) {
+-            try {
++    public Token peek()
++    {
++        if (tokens.isEmpty())
++        {
++            try
++            {
+                 lexOneToken();
+-            } catch (IOException e) {
++            }
++            catch (IOException e)
++            {
+                 throw new TokenizerIOException(e);
+             }
+         }
+@@ -151,7 +157,15 @@ public class Tokenizer implements Iterator<Token> {
+                     addToken(TokenType.MUL);
+                     break;
+                 case '/':
+-                    addToken(TokenType.DIV);
++                    if (in.peek() == '/')
++                    {
++                        in.nextLine();
++                        lexOneToken();
++                    }
++                    else
++                    {
++                        addToken(TokenType.DIV);
++                    }
+                     break;
+                 case '<':
+                     lexLAngle();
+@@ -174,7 +188,9 @@ public class Tokenizer implements Iterator<Token> {
+                     else addErrorToken(
+                         String.format("Unrecognized character %c", c));
+             }
+-        } catch (EOF eof) {
++        }
++        catch (EOF | UnexpectedInput eof)
++        {
+             addEOFToken();
+         }
+     }
+diff --git a/src/test/java/controller/ConsoleControllerTest.java b/src/test/java/controller/ConsoleControllerTest.java
+new file mode 100644
+index 0000000..767b084
+--- /dev/null
++++ b/src/test/java/controller/ConsoleControllerTest.java
+@@ -0,0 +1,177 @@
++package controller;
++
++import controller.DeterministicHexInformation.CritterHex;
++import model.ReadOnlyWorld;
++import org.junit.jupiter.api.Test;
++
++import java.nio.file.Paths;
++import java.util.Arrays;
++import java.util.List;
++import java.util.Objects;
++
++import static controller.DeterministicHexInformation.NonCritterHex.EMPTY_HEX;
++import static controller.DeterministicHexInformation.NonCritterHex.ROCK_HEX;
++import static org.junit.jupiter.api.Assertions.assertEquals;
++import static org.junit.jupiter.api.Assertions.assertTrue;
++
++public final class ConsoleControllerTest {
++    private static final String COMMON_TEST_PATH = Paths.get("src", "test", "resources", "A5files").toString();
++
++    @Test
++    public void testRandomWorld()
++    {
++        // Test a randomly generated world only contains empty and rock.
++        final var controller = ControllerFactory.getConsoleController();
++        controller.newWorld();
++        final var world = controller.getReadOnlyWorld();
++        for (int i = -1; i < 100; i++) {
++            for (int j = -1; j < 100; j++) {
++                if ((i + j) % 2 != 0) continue;
++
++                final var hexValue = world.getTerrainInfo(i, j);
++                if (i == -1 || j == -1) {
++                    assertEquals(-1, hexValue, "Out of bound tiles must have rock's hex values");
++                }
++                assertTrue(hexValue == 0 || hexValue == -1,
++                        "A randomly initialized world should only contain empty and rock tiles!");
++            }
++        }
++    }
++
++    @Test
++    public void emptyWorldTest() {
++        // An empty 10x10 empty world.
++        // This test mostly tests that the student's solution return -1 for hex outside of the world.
++        runTest(
++                Paths.get(COMMON_TEST_PATH, "empty.wld").toString(),
++                // Step 0
++                new StepState(0, new ExpectedHex(3, 3, EMPTY_HEX))
++        );
++    }
++
++    @Test
++    public void smallWorldTest() {
++        // A simple 1x1 empty world.
++        // This test mostly tests that the student's solution return -1 for hex outside of the world.
++        runTest(
++                Paths.get(COMMON_TEST_PATH, "small_world.txt").toString(),
++                // Step 0: the state of the world after load
++                new StepState(
++                        0,
++                        new ExpectedHex(0, 0, EMPTY_HEX),
++                        new ExpectedHex(1, 1, ROCK_HEX)),
++                // Step 1: the state of the world after one step
++                new StepState(
++                        0,
++                        new ExpectedHex(0, 0, EMPTY_HEX),
++                        new ExpectedHex(1, 1, ROCK_HEX),
++                        new ExpectedHex(-1, 31, ROCK_HEX),
++                        new ExpectedHex(-1, -1, ROCK_HEX))
++        );
++    }
++
++    @Test
++    public void spaceWorldTest() {
++        // A simple 1x1 world where the critter does nothing.
++        runTest(
++                Paths.get(COMMON_TEST_PATH, "space_world.txt").toString(),
++                // Step 0
++                new StepState(
++                        1,
++                        new ExpectedHex(0, 0, CritterHex.builderWithEnergy(500).build())
++                ),
++                // Step 1
++                new StepState(
++                        1,
++                        new ExpectedHex(0, 0, CritterHex.builderWithEnergy(500).build())
++                )
++        );
++    }
++
++    private void runTest(String worldFile, StepState initialState, StepState... steps) {
++        final var controller = ControllerFactory.getConsoleController();
++        assertTrue(controller.loadWorld(worldFile, false, false), String.format("World file %s failed to load.", worldFile));
++        checkState(controller.getReadOnlyWorld(), 0, initialState);
++        int stepId = 0;
++        while (stepId < steps.length) {
++            final var stepState = steps[stepId];
++            controller.advanceTime(1);
++            stepId++;
++            checkState(controller.getReadOnlyWorld(), stepId, stepState);
++        }
++    }
++
++    private static void checkState(ReadOnlyWorld world, int stepId, StepState stepState) {
++        assertEquals(stepId, world.getSteps(), "Step counter disagrees in step " + stepId);
++        assertEquals(stepState.population, world.getNumberOfAliveCritters(), "Critter population disagrees in step " + stepId);
++        for (final var expectedHex : stepState.expectedHexList) {
++            final var actualHexInformation =
++                    DeterministicHexInformation.fromWorldLocation(world, expectedHex.column, expectedHex.row);
++            assertEquals(
++                    expectedHex.information,
++                    actualHexInformation,
++                    "Hex information disagrees at (" + expectedHex.column + ", " + expectedHex.row + ") in step " + stepId);
++        }
++    }
++
++    private static final class StepState {
++        public final int population;
++        public final List<ExpectedHex> expectedHexList;
++
++        public StepState(int population, ExpectedHex... expectedHexList) {
++            this.population = population;
++            this.expectedHexList = Arrays.asList(expectedHexList);
++        }
++
++        @Override
++        public boolean equals(Object o) {
++            if (this == o) return true;
++            if (o == null || getClass() != o.getClass()) return false;
++            StepState stepState = (StepState) o;
++            return population == stepState.population &&
++                    expectedHexList.equals(stepState.expectedHexList);
++        }
++
++        @Override
++        public int hashCode() {
++            return Objects.hash(population, expectedHexList);
++        }
++
++        @Override
++        public String toString() {
++            return String.format("StepState{population=%d, expectedHexList=%s}", population, expectedHexList);
++        }
++    }
++
++    private static final class ExpectedHex {
++        public final int column;
++        public final int row;
++        public final DeterministicHexInformation information;
++
++        public ExpectedHex(int column, int row, DeterministicHexInformation information) {
++            this.column = column;
++            this.row = row;
++            this.information = information;
++        }
++
++        @Override
++        public boolean equals(Object o) {
++            if (this == o) return true;
++            if (o == null || getClass() != o.getClass()) return false;
++            ExpectedHex that = (ExpectedHex) o;
++            return column == that.column &&
++                    row == that.row &&
++                    information.equals(that.information);
++        }
++
++        @Override
++        public int hashCode() {
++            return Objects.hash(column, row, information);
++        }
++
++        @Override
++        public String toString() {
++            return String.format("ExpectedHex{column=%d, row=%d, information=%s}", column, row, information);
++        }
++    }
++}
+diff --git a/src/test/java/controller/ControllerTest.java b/src/test/java/controller/ControllerTest.java
+new file mode 100644
+index 0000000..2789a82
+--- /dev/null
++++ b/src/test/java/controller/ControllerTest.java
+@@ -0,0 +1,36 @@
++package controller;
++
++import controller.Controller;
++import controller.ControllerFactory;
++import org.junit.jupiter.api.Test;
++
++public class ControllerTest
++{
++    @Test
++    public void testLoadWorld()
++    {
++        Controller controller = ControllerFactory.getConsoleController();
++        controller.loadWorld("src\\test\\resources\\A5files\\test_world.txt", true, false);
++        controller.printWorld(System.out);
++    }
++
++    @Test
++    public void testNewWorld()
++    {
++        Controller controller = ControllerFactory.getConsoleController();
++        controller.newWorld();
++        controller.loadCritters("src\\test\\resources\\A5files\\test_critter.txt", 10);
++        controller.printWorld(System.out);
++    }
++
++    @Test
++    public void testAdvanceTimeStep()
++    {
++        Controller controller = ControllerFactory.getConsoleController();
++        controller.loadWorld("src\\test\\resources\\A5files\\test_world.txt", true, false);
++//        controller.printWorld(System.out);
++//        System.out.println();
++        controller.advanceTime(50);
++        controller.printWorld(System.out);
++    }
++}
+diff --git a/src/test/java/controller/DeterministicHexInformation.java b/src/test/java/controller/DeterministicHexInformation.java
+new file mode 100644
+index 0000000..22c0e9f
+--- /dev/null
++++ b/src/test/java/controller/DeterministicHexInformation.java
+@@ -0,0 +1,172 @@
++package controller;
++
++import model.ReadOnlyWorld;
++
++import java.util.ArrayList;
++import java.util.List;
++import java.util.Objects;
++
++/**
++ * Sealed class that records the hex information that is guaranteed to be deterministic.
++ */
++public abstract class DeterministicHexInformation {
++    private DeterministicHexInformation() {}
++
++    public static final class NonCritterHex extends DeterministicHexInformation {
++        public static final DeterministicHexInformation ROCK_HEX = new NonCritterHex(-1);
++        public static final DeterministicHexInformation EMPTY_HEX = new NonCritterHex(0);
++
++        public final int hexValue;
++
++        public NonCritterHex(int hexValue) {
++            this.hexValue = hexValue;
++        }
++
++        @Override
++        public boolean equals(Object o) {
++            if (this == o) return true;
++            if (o == null || getClass() != o.getClass()) return false;
++            NonCritterHex that = (NonCritterHex) o;
++            return hexValue == that.hexValue;
++        }
++
++        @Override
++        public int hashCode() {
++            return Integer.hashCode(hexValue);
++        }
++
++        @Override
++        public String toString() {
++            return "NonCritterHex{ hexValue=" + hexValue + " }";
++        }
++    }
++
++    public static final class CritterHex extends DeterministicHexInformation {
++        public final int memorySize;
++        public final int defense;
++        public final int offense;
++        public final int size;
++        public final int energy;
++        public final int posture;
++        public final List<Integer> otherMemorySlots;
++
++        public CritterHex(
++                int memorySize,
++                int defense,
++                int offense,
++                int size,
++                int energy,
++                int posture,
++                List<Integer> otherMemorySlots) {
++            this.memorySize = memorySize;
++            this.defense = defense;
++            this.offense = offense;
++            this.size = size;
++            this.energy = energy;
++            this.posture = posture;
++            this.otherMemorySlots = otherMemorySlots;
++        }
++
++        @Override
++        public boolean equals(Object o) {
++            if (this == o) return true;
++            if (o == null || getClass() != o.getClass()) return false;
++            CritterHex that = (CritterHex) o;
++            return memorySize == that.memorySize &&
++                    defense == that.defense &&
++                    offense == that.offense &&
++                    size == that.size &&
++                    energy == that.energy &&
++                    posture == that.posture &&
++                    otherMemorySlots.equals(that.otherMemorySlots);
++        }
++
++        @Override
++        public int hashCode() {
++            return Objects.hash(memorySize, defense, offense, size, energy, posture, otherMemorySlots);
++        }
++
++        @Override
++        public String toString() {
++            return String.format(
++                    "CritterHex{memorySize=%d, defense=%d, offense=%d, size=%d, energy=%d, posture=%d, otherMemorySlots=%s}",
++                    memorySize,
++                    defense,
++                    offense,
++                    size,
++                    energy,
++                    posture,
++                    otherMemorySlots);
++        }
++
++        static Builder builderWithEnergy(int energy) {
++            return new Builder(energy);
++        }
++
++        /**
++         * Use this builder so that we don't have to supply some default values every time.
++         */
++        public static final class Builder {
++            private int memorySize = 7;
++            private int defense = 1;
++            private int offense = 1;
++            private int size = 1;
++            private final int energy;
++            private int posture = 0;
++            private List<Integer> otherMemorySlots = List.of();
++
++            private Builder(int energy) {
++                this.energy = energy;
++            }
++
++            public Builder setMemorySize(int memorySize) {
++                this.memorySize = memorySize;
++                return this;
++            }
++
++            public Builder setDefense(int defense) {
++                this.defense = defense;
++                return this;
++            }
++
++            public Builder setOffense(int offense) {
++                this.offense = offense;
++                return this;
++            }
++
++            public Builder setSize(int size) {
++                this.size = size;
++                return this;
++            }
++
++            public Builder setPosture(int posture) {
++                this.posture = posture;
++                return this;
++            }
++
++            public Builder setOtherMemorySlots(List<Integer> otherMemorySlots) {
++                this.otherMemorySlots = otherMemorySlots;
++                return this;
++            }
++
++            public CritterHex build() {
++                return new CritterHex(memorySize, defense, offense, size, energy, posture, otherMemorySlots);
++            }
++        }
++    }
++
++    public static DeterministicHexInformation fromWorldLocation(ReadOnlyWorld world, int column, int row) {
++        return world.getReadOnlyCritter(column, row).<DeterministicHexInformation>then(critter -> {
++            final var memory = critter.getMemory();
++            List<Integer> otherMemorySlots = new ArrayList<>();
++            for (int i = 7; i < memory.length; i++) {
++                otherMemorySlots.add(memory[i]);
++            }
++            return new CritterHex(memory[0], memory[1], memory[2], memory[3], memory[4], memory[6], otherMemorySlots);
++        }).orElseGet(() -> new NonCritterHex(world.getTerrainInfo(column, row)));
++    }
++
++    public static DeterministicHexInformation foodHex(int amount) {
++        return new NonCritterHex(-1 - amount);
++    }
++}
+diff --git a/src/test/java/parser/ParserTest.java b/src/test/java/parser/ParserTest.java
+index 05abb5d..8219323 100644
+--- a/src/test/java/parser/ParserTest.java
++++ b/src/test/java/parser/ParserTest.java
+@@ -22,17 +22,18 @@ public class ParserTest
+     @Test
+     public void testProgramIsNotNone()
+     {
+-        InputStream in = ClassLoader.getSystemResourceAsStream("files/draw_critter_2.txt");
++        InputStream in = ClassLoader.getSystemResourceAsStream("files/draw_critter_5.txt");
+         Reader r = new BufferedReader(new InputStreamReader(in));
+         Parser parser = ParserFactory.getParser();
+ 
+         try
+         {
+             Program prog = parser.parse(r);
+-            System.out.println(prog.toString());
++            System.out.println(prog);
+         }
+         catch(SyntaxError e)
+         {
++            System.out.println(e);
+             fail("A valid program should not have syntax errors");
+         }
+     }
+@@ -201,7 +202,7 @@ public class ParserTest
+         try
+         {
+             Program prog = parser.parse(r);
+-            Node target = prog.nodeAt((int) (Math.random() * prog.size()));;
++            Node target = prog.nodeAt((int) (Math.random() * prog.size()));
+             while (!(mut.canApply(target)))
+             {
+                 target = prog.nodeAt((int) (Math.random() * prog.size()));
+@@ -247,4 +248,77 @@ public class ParserTest
+             fail("A valid program should not have syntax errors");
+         }
+     }
++
++    @Test
++    public void testBigRandom() throws SyntaxError
++    {
++        InputStream in = ClassLoader.getSystemResourceAsStream("files/draw_critter_2.txt");
++        Reader r = new BufferedReader(new InputStreamReader(in));
++        Parser parser = ParserFactory.getParser();
++        Program prog = parser.parse(r);
++//        Mutation mut = MutationFactory.getSwap();
++        Node target = prog.nodeAt((int) (Math.random() * prog.size()));
++        for (int i = 0; i < 1000; i++)
++        {
++            target = prog.nodeAt((int) (Math.random() * prog.size()));
++            System.out.println(i);
++            Mutation mut;
++            int mutationPicker = (int) (Math.random() * 6);
++            if (mutationPicker == 0)
++            {
++                mut = MutationFactory.getRemove();
++            }
++            else if (mutationPicker == 1)
++            {
++                mut = MutationFactory.getSwap();
++            }
++            else if (mutationPicker == 2)
++            {
++                mut = MutationFactory.getReplace();
++            }
++            else if (mutationPicker == 3)
++            {
++                mut = MutationFactory.getTransform();
++            }
++            else if (mutationPicker == 4)
++            {
++                mut = MutationFactory.getInsert();
++            }
++            else
++            {
++                mut = MutationFactory.getDuplicate();
++            }
++
++            int count = 0;
++            while (!(mut.canApply(target)) && count < 50)
++            {
++                target = prog.nodeAt((int) (Math.random() * prog.size()));
++                count++;
++            }
++            try
++            {
++                mut.apply(prog, target);
++//                System.out.println(mut.canApply(target));
++            }
++            catch (IndexOutOfBoundsException | StackOverflowError | NullPointerException e)
++            {
++                System.out.println(e);
++                System.out.println();
++                System.out.println(prog);
++                System.out.println();
++                System.out.println(mut.getClass());
++                System.out.println();
++                System.out.println(target);
++                System.out.println();
++                throw e;
++            }
++        }
++        System.out.println();
++        System.out.println(prog);
++        System.out.println();
++        System.out.println(target);
++        System.out.println();
++        System.out.println(target.getClass());
++    }
+ }
++
+diff --git a/src/test/resources/A5files/empty.wld b/src/test/resources/A5files/empty.wld
+new file mode 100644
+index 0000000..1dfc3bb
+--- /dev/null
++++ b/src/test/resources/A5files/empty.wld
+@@ -0,0 +1,2 @@
++name empty
++size 10 10
+diff --git a/src/test/resources/A5files/mate_critter.txt b/src/test/resources/A5files/mate_critter.txt
+new file mode 100644
+index 0000000..1be7b30
+--- /dev/null
++++ b/src/test/resources/A5files/mate_critter.txt
+@@ -0,0 +1,8 @@
++species: mate critter
++memsize: 7
++defense: 1
++offense: 1
++size: 1
++energy: 500
++posture: 0
++1 = 1 --> mate;
+\ No newline at end of file
+diff --git a/src/test/resources/A5files/small_world.txt b/src/test/resources/A5files/small_world.txt
+new file mode 100644
+index 0000000..77a4f7e
+--- /dev/null
++++ b/src/test/resources/A5files/small_world.txt
+@@ -0,0 +1,2 @@
++name Small
++size 1 1
+diff --git a/src/test/resources/A5files/space_critter.txt b/src/test/resources/A5files/space_critter.txt
+new file mode 100644
+index 0000000..b23b112
+--- /dev/null
++++ b/src/test/resources/A5files/space_critter.txt
+@@ -0,0 +1,8 @@
++species: space critter
++memsize: 7
++defense: 1
++offense: 1
++size: 1
++energy: 500
++posture: 0
++1 = 1 --> wait;
+diff --git a/src/test/resources/A5files/space_world.txt b/src/test/resources/A5files/space_world.txt
+new file mode 100644
+index 0000000..b9a4161
+--- /dev/null
++++ b/src/test/resources/A5files/space_world.txt
+@@ -0,0 +1,3 @@
++name space world
++size 1 1
++critter space_critter.txt 0 0 0
+diff --git a/src/test/resources/A5files/test_critter.txt b/src/test/resources/A5files/test_critter.txt
+new file mode 100644
+index 0000000..b1a27b6
+--- /dev/null
++++ b/src/test/resources/A5files/test_critter.txt
+@@ -0,0 +1,16 @@
++species: test critter
++memsize: 8
++defense: 1
++offense: 1
++
++size: 5
++energy: 2500
++posture: 0
++// test
++POSTURE != 17 --> POSTURE := 17;
++{ahead[0] = 1} --> forward;
++{nearby[3] = 0 and ENERGY > 2500} --> bud;
++{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
++ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
++(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
++1 = 1 --> wait;
+\ No newline at end of file
+diff --git a/src/test/resources/A5files/test_world.txt b/src/test/resources/A5files/test_world.txt
+new file mode 100644
+index 0000000..9cac6ad
+--- /dev/null
++++ b/src/test/resources/A5files/test_world.txt
+@@ -0,0 +1,6 @@
++name test world
++size 18 21
++// test
++
++critter space_critter.txt 0 0 0
++critter test_critter.txt 2 4 5
+\ No newline at end of file
+diff --git a/src/test/resources/files/draw_critter_3.txt b/src/test/resources/files/draw_critter_3.txt
+new file mode 100644
+index 0000000..0cc0bc8
+--- /dev/null
++++ b/src/test/resources/files/draw_critter_3.txt
+@@ -0,0 +1,9 @@
++3 > ahead[-1] - (mem[-7] + 6) --> mem[6] := mem[mem[4]] mem[mem[mem[-1]]] := -1 mem[6] := 6 mem[6] := 6 mem[2] := 17 mem[6] := mem[-6] mem[mem[2]] := -1 mem[6] := 6;
++3 != mem[6] / mem[3] and 2 != -1 --> mem[6] := 3 mem[-1] := 17 mem[17] := 17 mem[6] := 18 mem[6] := 6 mem[mem[mem[mem[mem[mem[mem[mem[6]]]]]]]] := mem[4] mem[mem[mem[mem[6]]]] := mem[4] mem[2] := 2;
++mem[6] > 17 and {-1 < 3 or 1 < 17} --> mem[-1] := 3 mem[2] := 2 mem[11] := 17 mem[2] := 3 mem[1] := mem[4] mem[2500] := 17 mem[-2] := 13 mem[mem[mem[mem[mem[mem[mem[6]]]]]]] := mem[4] mem[mem[2]] := 1 mem[2] := mem[mem[mem[17]]] mem[2] := mem[mem[mem[17]]] mem[6] := 6 bud;
++mem[3] > 2500 and 3 < -1 and -1 - 2500 < 3 and mem[3] / 2500 * 2 + 6 >= 4 and -1 * 2500 < 3 and {2 * (mem[3] / mem[1] mod (2 * mem[6] + 6)) + 6 >= 4 or 17 > 6 and 2500 >= mem[mem[3]]} and mem[2] > 2500 --> mem[4] := mem[3] mem[mem[mem[mem[mem[6 + 3 mod (mem[6] mod mem[-1])]]]]] := 4 mem[6] := 17 mem[mem[-5]] := 3 mem[mem[2]] := -1 mem[mem[-1]] := mem[-1] bud;
++3 * mem[mem[2]] > 7 + (mem[3] - -1) - ahead[1] and {-5 < 1 and 17 > mem[6] and 2500 >= mem[mem[3]] and mem[6] < mem[-13] * -1 and mem[4] >= 2 * (mem[3] / mem[6]) + 6 and 3 / 7 < -1 or mem[6] > 17} --> mem[2] := 18 mem[mem[mem[-1]]] := -6 mem[6] := 6 mem[mem[mem[mem[mem[mem[mem[mem[6]]]]]]]] := mem[4] mem[17] := 17 mate;
++4 = 7 or 2500 > mem[-1] and nearby[3] = 7 or 2 - 7 = nearby[3] or -1 < 3 and mem[17] - 1 * -1 + 6 >= 6 or 2 * (mem[3] / 2500 / 17) + 6 mod 4 >= 4 --> mem[mem[mem[-4]]] := 4 mem[-1] := mem[2] mem[mem[6]] := 4 mem[2] := 17 mem[-1] := -6 bud;
++4 = mem[6] or {1 = 7 - mem[6] or -1 < 3 and 3 / 3 < -1 and mem[4] >= mem[3] / mem[6] * 2 + 6 and mem[4] >= 6 mod -1 * mem[6] and 6 + 45 mod mem[mem[mem[6]]] * (mem[6] - 2) >= mem[mem[1]]} and nearby[3] = 7 --> mem[6] := 6 mem[6] := 17 mem[6] := 4 mem[mem[mem[2]]] := 17 mem[6] := 6 mem[mem[-12]] := -7 mem[2] := 17 mem[mem[6]] := 6 mem[6] := 17 mem[mem[mem[mem[2]]]] := 17 mem[-1] := -6 mem[17] := 17;
++mem[2] * 3 > mem[2] - (mem[3] - -1 + 7) and {7 < 1 and 2500 >= mem[-1] and mem[mem[3]] > mem[6] and 7 < 1 and 7 mod -17 > mem[6] and 7 >= 3 and {3 > 6 - mem[-1] or nearby[3] = 7} and 3 >= 3 or {7 < 1 and -7 >= mem[mem[mem[6 - mem[-2]]]] and 17 > mem[6] or 4 >= 6 mod mem[mem[-6]] + 6 * 6} and 1 < mem[6] and 3 / 3 <= -1 and mem[4] >= 2 * (3 / mem[6]) + 6} --> mem[2] := -6 mem[-1] := -6 mem[6] := 3 * mem[mem[2]] mem[mem[mem[mem[mem[mem[3] / mem[6]]]]]] := mem[4] mem[-1] := -6 mem[mem[mem[mem[6]]]] := mem[4] mem[6] := 6 mem[6] := 4 mate;
++(6 + 6) / mem[3] != 3 and 2 != -1 --> mem[mem[mem[mem[mem[mem[6]]]]]] := mem[4] mem[-1] := 17 mem[17] := 17 mem[6] := 4 mem[2] := 2 mem[2] := mem[mem[mem[17]]] mem[mem[mem[mem[mem[6]]]]] := mem[4] mem[mem[6]] := mem[6];
+\ No newline at end of file
+diff --git a/src/test/resources/files/draw_critter_4.txt b/src/test/resources/files/draw_critter_4.txt
+new file mode 100644
+index 0000000..049137d
+--- /dev/null
++++ b/src/test/resources/files/draw_critter_4.txt
+@@ -0,0 +1,13 @@
++mem[mem[17]] != mem[mem[6]] and mem[mem[-1]] != mem[6] and mem[4] >= 17 - -1 --> mem[-3] := -113 mem[mem[-3]] := mem[-13] mem[mem[mem[-1]]] := mem[mem[mem[mem[6]]]] mem[mem[-1]] := mem[-2] mem[6] := -14 mem[mem[mem[mem[mem[mem[mem[1]]]]]]] := mem[mem[5]] mem[mem[-6]] := -6 mem[1] := -1 / (17 / (17 * -1)) mem[-1] := 17 * -1 eat;
++mem[mem[-1]] != mem[6] and 17 * -1 * 1 > mem[mem[4]] --> mem[6] := -1 mem[-3] := 3 mem[mem[mem[1]]] := mem[mem[mem[17]]] mem[mem[mem[-1]]] := mem[mem[17]] mem[-1] := mem[mem[mem[5]]] mem[-6] := -6 mem[-1] := -1 * -1 mem[-1] := 6 mem[mem[mem[-1]]] := 17 * -1 mem[-1] := mem[1] mem[mem[mem[-1]]] := 17 * -1 mem[mem[mem[-1]]] := mem[mem[mem[1]]] mem[4] := 16 eat;
++17 / -1 != mem[3] --> mem[mem[mem[mem[mem[mem[6]]]]]] := mem[1] mem[-1] := -1 mem[2] := 2 mem[-2] := -2 mem[-1] := mem[mem[mem[mem[17]]]] mem[mem[mem[mem[17]]]] := mem[mem[-2]] mem[mem[mem[-6]]] := -6 mem[-1] := mem[56] mem[-3] := -3 mem[mem[-3]] := mem[mem[mem[1]]] mem[-1] := mem[mem[mem[1]]] forward;
++-1 = 6 --> mem[mem[-1]] := mem[56] mem[1] := 1 mem[-1] := mem[mem[mem[mem[mem[mem[mem[84]]]]]]] mem[-1] := 17 mem[mem[-3]] := 1 mem[mem[mem[6]]] := mem[mem[6]] mem[6] := mem[6] mem[-1] := -1 mem[mem[1]] := mem[mem[1]] mem[-1] := 17 eat;
++1 = -1 --> mem[6] := mem[mem[mem[4]]] mem[mem[mem[mem[1]]]] := mem[2] mem[1] := mem[3] mem[-1] := mem[1] mem[-1] := 17 mem[-1] := mem[-1] mem[mem[mem[6]]] := -14 mem[-1] := mem[mem[mem[17]]] mem[-1] := 17 mem[56] := -1 mem[mem[2]] := 4 mem[mem[6]] := mem[mem[mem[mem[mem[-1]]]]] mem[-1] := 17 mem[-1] := mem[mem[-1]] mem[-1] := 17 mem[-1] := -9;
++mem[-1] * mem[mem[mem[6]]] != 2 --> mem[-3] := -3 mem[-1] := mem[56] mem[-1] := -9 mem[-1] := 6 mem[1] := mem[mem[mem[-5]]] mem[mem[mem[6]]] := 6 mem[-1] := -1;
++6 < -1 --> mem[4] := -6 mem[mem[mem[mem[mem[mem[mem[1]]]]]]] := mem[mem[6]] mem[mem[mem[-3]]] := 1 mem[-1] := mem[mem[mem[1]]] mem[mem[mem[4]]] := mem[mem[mem[-41]]] mem[6] := mem[6] mem[-1] := -1 mem[mem[mem[mem[6]]]] := mem[mem[mem[1]]] mem[mem[mem[17]]] := mem[6] mem[-1] := mem[mem[5]] mem[-3] := 1 mem[-1] := mem[56] mem[-1] := mem[mem[17]] mem[6] := -1;
++1 = -1 --> mem[6] := mem[mem[mem[mem[4]]]] mem[mem[mem[mem[1]]]] := 6 mem[1] := mem[3] mem[-1] := mem[1] mem[-1] := 17 mem[-1] := -1 mem[mem[mem[6]]] := -14 mem[-1] := mem[mem[mem[17]]] mem[-1] := 17 mem[mem[-1]] := 17 * -1 mem[mem[2]] := 4 mem[mem[6]] := mem[mem[mem[mem[mem[-1]]]]] mem[-3] := -3 mem[-1] := mem[mem[mem[mem[mem[1]]]]] mem[-1] := mem[-1];
++mem[17] mod mem[mem[mem[6]]] != 2 --> mem[6] := mem[6] mem[mem[mem[6]]] := mem[3] mem[-3] := 1 mem[6] := mem[mem[mem[6]]] mem[-1] := mem[mem[5]] mem[6] := mem[mem[6]];
++17 * -1 != mem[-1] and mem[mem[3]] != (mem[1] - -1) * 17 --> mem[6] := 6 mem[6] := mem[mem[mem[6]]] mem[mem[56]] := 56 mem[6] := mem[mem[mem[mem[6]]]] mem[-1] := mem[mem[mem[2]]] mem[-1] := mem[mem[mem[-1]]] mem[mem[-3]] := mem[mem[1]] mem[-1] := -1 mem[5] := -6 mem[mem[mem[-1]]] := mem[mem[mem[mem[6]]]];
++mem[mem[17 * -1]] != 17 / -1 --> mem[mem[mem[mem[1]]]] := mem[mem[mem[-7]]] mem[-1] := 1 mem[-1] := mem[mem[5]] mem[-1] := mem[mem[mem[mem[mem[mem[mem[-1]]]]]]] mem[6] := -14 mem[1] := -6 mem[mem[-1]] := 17 mem[6] := 6 mem[-1] := mem[14 * -1] mem[mem[mem[-1]]] := mem[mem[mem[1]]] mem[mem[6]] := -14 mem[mem[mem[mem[6]]]] := mem[mem[mem[1]]] mem[-3] := mem[3] mem[-1] := -9 mem[-1] := 17 eat;
++17 * 6 != mem[mem[4]] and -1 * 17 != mem[-1] --> mem[-6] := -6 mem[mem[mem[mem[-1]]]] := mem[-1] mem[mem[-1]] := mem[mem[mem[56]]] mem[56] := 56 mem[mem[1]] := 1 mem[mem[-1]] := -1 mem[-1] := mem[mem[5]] mem[mem[-1]] := mem[mem[mem[mem[1]]]] mem[-1] := -1 mem[1] := 6 mem[mem[mem[17]]] := mem[mem[6]] mem[mem[mem[17]]] := mem[6] mem[mem[mem[6]]] := -14 attack;
++mem[17] mod mem[mem[mem[6]]] != 2 --> mem[6] := mem[6] mem[mem[mem[6]]] := mem[3] mem[-3] := 1 mem[6] := mem[mem[mem[6]]] mem[-1] := mem[mem[5]] mem[6] := mem[mem[6]];
+\ No newline at end of file
+diff --git a/src/test/resources/files/draw_critter_5.txt b/src/test/resources/files/draw_critter_5.txt
+new file mode 100644
+index 0000000..9ccbf3e
+--- /dev/null
++++ b/src/test/resources/files/draw_critter_5.txt
+@@ -0,0 +1,12 @@
++ahead[6] < -1 mod mem[1] mod mem[1] --> mem[-1] := mem[-1] mem[1] := 1 mem[mem[-1]] := mem[3] mem[4] := 4 mem[6] := -1 mem[4] := 4 mem[mem[3]] := 2 bud;
++6 = 1 * 17 and {-1 != -3 or 4 < 2 / 3 or -1 < mem[mem[mem[mem[1]]]]} and -1 mod mem[1] < ahead[6] --> mem[mem[1]] := 3 mem[mem[1]] := mem[1] mem[mem[2]] := 1 mem[1] := mem[mem[-9]] mem[1] := 1 mem[6] := 17 mem[-1] := ahead[6] mem[6] := 4 mem[6] := 6 mem[1] := mem[mem[1]] mem[mem[-2]] := 2;
++4 != 1 and 6 < 1 mod mem[1] --> mem[mem[3]] := -8 mem[mem[6]] := 6 mem[mem[3]] := 1 mem[6] := 17 mem[6] := 6 mem[mem[mem[6]]] := 2 mem[mem[2]] := 6 mem[6] := -3 mem[6] := mem[1] mem[6] := 1 mem[mem[1]] := mem[6] mem[1] := mem[-23] mem[1] := mem[mem[1]] mem[mem[1]] := 6 left;
++6 < mem[1] mod 1 --> mem[mem[3]] := -8 mem[mem[6]] := 6 mem[mem[3]] := 1 mem[6] := 6 mem[6] := 6 mem[mem[6]] := 2 mem[mem[2]] := 6 mem[6] := -3 mem[6] := mem[1] mem[6] := 1 mem[mem[1]] := mem[6] mem[1] := mem[-23] mem[1] := mem[mem[-9]] mem[mem[1]] := 6 mem[1] := mem[-9] mem[6] := 4 left;
++4 <= mem[3] / -3 --> mem[-1] := 0 mem[mem[1]] := -22 mem[3] := 6 mem[mem[3]] := mem[1 * -1] mem[-1] := -1 mem[mem[3]] := mem[-1] mem[6] := mem[1] mem[1 + (-1 + 1 mod (mem[1] / mem[-1]))] := -1 mem[1] := mem[-9] mem[1] := mem[mem[-9]] mem[mem[3]] := -8;
++(-1 + -1 / -1) * 1 - 6 <= mem[mem[mem[1]]] --> mem[2] := 2 mem[mem[mem[1] + (1 * 6 mod -95 - mem[-1])]] := -2 mem[-1] := 17 mem[1] := mem[6] mem[mem[-1]] := 17 mem[mem[1]] := mem[6] mem[6] := 6 mem[1] := mem[-2] mem[-1] := ahead[6] mem[1] := mem[-23] left;
++-1 * -1 / (-1 * mem[1] * ((3 - mem[1]) / ahead[2])) < mem[7] or 4 < -1 --> mem[1] := -1 mem[mem[2]] := 6 mem[-3] := 0 mem[mem[1]] := 6 mem[mem[-1]] := ahead[1] mem[6] := -3 mem[2] := 4 mem[6] := 6 mem[1] := 6 mem[-1] := ahead[1];
++mem[mem[1]] <= (-1 / -1 + -1) * 1 --> mem[-2] := 2 mem[2] := 2 mem[6] := 6 mem[-1] := 17 mem[-1] := mem[mem[6]] mem[mem[-1]] := 17 mem[mem[1]] := mem[6] mem[6] := 6 mem[17 + (-95 mod 1 - -1)] := -1 mem[-3] := -2 mem[mem[mem[3]]] := mem[-1] left;
++-3 != -1 or 6 < 3 / 2 or -3 < mem[mem[mem[mem[1]]]] --> mem[mem[1]] := 1 mem[500] := mem[3] mem[6] := 17 mem[mem[-31]] := mem[mem[6]] mem[6] := mem[mem[-1]] mem[mem[1]] := 6 mem[1] := 1 mem[6] := -1 left;
++ahead[6] < -1 mod 1 or -1 != -1 or {mem[mem[1]] != -1 + 1 mod mem[mem[mem[1]]] + 17 or -2 < ahead[-35] mod (mem[6] + 4) mod -3} and {-3 != -1 or 6 < 2 * mem[mem[1]] / 3} --> mem[-23] := mem[6] mem[mem[mem[3]]] := 2 mem[-1] := mem[mem[-1]] mem[6] := 17 mem[6] := -1 mem[3] := mem[6] mem[-1] := mem[1] mem[6] := mem[6] mem[mem[-3]] := 6 mem[-31] := 4 mem[-31] := mem[4] mem[1] := mem[mem[mem[1]]] mem[mem[1]] := mem[1] mem[-1] := 0 mem[2] := 2 mem[mem[1]] := 6 mem[1] := mem[mem[-9]] bud;
++4 >= ahead[-3] / mem[-1 - 1 + -1 * mem[1] / -9] --> mem[-1] := 0 mem[-1] := 6 mem[mem[3]] := mem[0] mem[-3] := -1 mem[mem[mem[3]]] := mem[-1] mem[mem[6]] := mem[(-1 + -1 / -1) * 3 - 6] mem[1 + (-1 + (1 mod (mem[1] / mem[-1]) + mem[6] + 4 mod ahead[-35] mod -3))] := -1 mem[mem[mem[-1]]] := 4 mem[1] := -9;
++mem[1] <= (3 / -1 + -1) * 1 --> mem[-2] := 2 mem[2] := 2 mem[mem[17 + (1 - -95 - -1)]] := mem[-1] mem[-1] := 17 mem[-1] := mem[mem[6]] mem[mem[-1]] := 17 mem[mem[1]] := mem[6] mem[6] := 6 mem[6] := 6 mem[1] := -2 mem[1] := mem[mem[-9]] left;
+\ No newline at end of file
+diff --git a/src/test/resources/files/mutated_critter_1.txt b/src/test/resources/files/mutated_critter_1.txt
+index 1ceca44..9bd1c39 100644
+--- a/src/test/resources/files/mutated_critter_1.txt
++++ b/src/test/resources/files/mutated_critter_1.txt
+@@ -13,3 +13,4 @@ nearby[0] > 0 and nearby[3] = 0 --> backward;
+ ahead[1] < -1 and { ENERGY > 2500 or SIZE > 7 } --> serve[ENERGY / 42];
+ random[3] = 1 --> left;
+ 1 = 1 --> wait;
++// test
+\ No newline at end of file
diff --git a/log.txt b/log.txt
new file mode 100644
index 0000000..30dc9ff
--- /dev/null
+++ b/log.txt
@@ -0,0 +1,210 @@
+commit a3639fee4759e5f7e9e02b6acfeaceaf339ce13d
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 23:11:44 2022 -0500
+
+    removed more useless import statements
+
+commit 33761923ef5194d3ee197ee6ac648df8467b61a5
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 23:08:42 2022 -0500
+
+    change import statements
+
+commit 375810dee047be9921e09812fd5d18718561d31a
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 23:06:33 2022 -0500
+
+    removed file for submission
+
+commit 12947c04e23eb41bf513b71a8e00d3e66e3d60ab
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 23:04:42 2022 -0500
+
+    fixed ParseAndMutateApp
+
+commit 9c984d9d8e828128fe6dc8e563e1cbbc15d81753
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 16:28:39 2022 -0500
+
+    idk
+
+commit f4e097820cb57974ced4434a0f43ead5535aeef8
+Merge: 2dc1764 351675e
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 16:10:40 2022 -0500
+
+    fix merge conflict
+
+commit 2dc17640bd28b83f879ded202e3ea3d1833a3f5e
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 16:07:20 2022 -0500
+
+    idk
+
+commit 351675e9d2d653626f446257fd44fad389377e91
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Tue Nov 8 15:47:57 2022 -0500
+
+    Everything written
+
+commit 83ca663bc280bc153452864536abe2bdb44a46e2
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 13:14:31 2022 -0500
+
+    tested mutations
+
+commit 29017a9ba1aba3e6028a774bc837d2de092b3a6b
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Tue Nov 8 02:02:23 2022 -0500
+
+    testing mutations
+
+commit 84273be81299ddc221d2384f2311628f5197d529
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Tue Nov 8 00:30:30 2022 -0500
+
+    Errors Fixed
+
+commit 72e22a60bdec94169c2d19e2e80ea1ccaf93c69a
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Mon Nov 7 22:32:55 2022 -0500
+
+    testing remove mutation
+
+commit ec17983630e1fc26725ce410bb84b175432803b1
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Mon Nov 7 19:22:42 2022 -0500
+
+    fixed prettyPrint() for BinaryOp
+
+commit 535162ab6f358c4edcb01b0daa61955de96976a4
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Mon Nov 7 13:44:18 2022 -0500
+
+    Finished Pretty Printing
+
+commit fe7a9af4e23ae290db16faf6d11c4f67ac7d68b0
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Mon Nov 7 12:17:53 2022 -0500
+
+    PrettyPrint
+
+commit ad20c573f71516a718ab407367633db17a4dcc91
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Sun Nov 6 23:53:19 2022 -0500
+
+    finished mutations hopefully
+
+commit 5f32bfa39b7a64a74decc1314b69a4008e947826
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Sun Nov 6 18:34:47 2022 -0500
+
+    implemented more mutations
+
+commit 651c464d878f423a20f384486c76a5fc59b30598
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Sun Nov 6 01:09:59 2022 -0500
+
+    I broke my damn phone
+
+commit e45d1eadadc32f7aea94e402a80155837c5afb73
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Sun Nov 6 00:10:58 2022 -0400
+
+    changed remove mutation for negative expr
+
+commit 219dda15e0771c49df2b3d859fcf3cba2f6debe0
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Sun Nov 6 00:07:17 2022 -0400
+
+    fixed clone() in mem
+
+commit 5534bf3ff1a5a332b6e543bdce3b241519a6388d
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Sun Nov 6 00:06:16 2022 -0400
+
+    implement swap mutation
+
+commit 2ad437f3ecf2423f9ca6352f3562b74a7045e8d9
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Sat Nov 5 21:44:33 2022 -0400
+
+    tested ParserImpl and implemented Remove
+
+commit d6c8b2f501ffc642bc8153a60140324b37ca38b3
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Fri Nov 4 20:20:16 2022 -0400
+
+    forgot semicolon
+
+commit 99fc466f71236523763bac79bf094f228aae4823
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Fri Nov 4 20:19:39 2022 -0400
+
+    added parent pointers and change structure of mutations
+
+commit aaaf325323391658dd24f4a91f7d3a4af1a664ef
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Fri Nov 4 00:34:15 2022 -0400
+
+    added mutations classes
+
+commit db43745ba215c26a55d45fe36826534b76902be7
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Thu Nov 3 23:47:35 2022 -0400
+
+    added negative node and negative expr
+
+commit bc01048481f1ac8e80edd52e9d1893218dd4fd9c
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Wed Nov 2 22:29:45 2022 -0400
+
+    deleted duplicate class
+
+commit db13b13db5b9d6bc3cb00d4ac9c56dbdcece3d31
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Wed Nov 2 22:28:53 2022 -0400
+
+    finished AST
+
+commit ff3c70ba7617fcb7f5a911494e660fe7b31c6ba5
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Tue Nov 1 00:10:24 2022 -0400
+
+    bruh
+
+commit 362d7d3bbe6d4b4d3b0f5c2ce9cedc134a6b17f4
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Mon Oct 31 22:37:51 2022 -0400
+
+    heehee
+
+commit 26f338ed02aac4baf473205727b174a6886b9963
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Mon Oct 31 17:23:07 2022 -0400
+
+    Commit 1
+
+commit 8f8494028804d2d41b880fd02256e49f9f821090
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Sun Oct 30 21:16:38 2022 -0400
+
+    stuff
+
+commit 09a7fa9992c9dbbcfa4187ff44d644d89f635986
+Author: Richard Lin <rl659@cornell.edu>
+Date:   Wed Oct 26 01:51:24 2022 -0400
+
+    heehee
+
+commit 135253f3566982a3baa190922a359f27b9206f3f
+Author: BenjaminL1 <43938864+BenjaminL1@users.noreply.github.com>
+Date:   Sun Oct 23 21:47:32 2022 -0400
+
+    Commit 1
+
+commit d04b083ff93ddb3d0f0cfee9b3fbec533328b6f6
+Author: Shiyuan Huang <shiyuancn@live.cn>
+Date:   Mon Oct 17 18:49:43 2022 -0400
+
+    Initial commit
diff --git a/settings.gradle b/settings.gradle
index 1385ed8..c816aa6 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1 @@
-rootProject.name = 'CHANGE ME'
+rootProject.name = 'Critterworld'
\ No newline at end of file
diff --git a/src/main/java/ast/AbstractNode.java b/src/main/java/ast/AbstractNode.java
index f86b603..68860c2 100644
--- a/src/main/java/ast/AbstractNode.java
+++ b/src/main/java/ast/AbstractNode.java
@@ -31,6 +31,7 @@ public abstract class AbstractNode implements Node
     @Override
     public Node nodeAt(int index)
     {
+        if(index < 0 || index >= this.size()) throw new IndexOutOfBoundsException();
         Queue<Node> queue = new LinkedList<Node>();
         queue.add(this);
         int count = 0;
diff --git a/src/main/java/ast/Action.java b/src/main/java/ast/Action.java
index 0016c20..5c6f37a 100644
--- a/src/main/java/ast/Action.java
+++ b/src/main/java/ast/Action.java
@@ -3,6 +3,8 @@ package ast;
 import parse.TokenType;
 
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 
 public class Action extends AbstractNode
@@ -48,7 +50,7 @@ public class Action extends AbstractNode
             list.add(value);
             return list;
         }
-        else return null;
+        else return new ArrayList<>();
     }
 
     @Override
@@ -83,7 +85,6 @@ public class Action extends AbstractNode
 
     public void changeExpr(Expr e)
     {
-        value.setParent(null);
         value = e;
         value.setParent(this);
     }
diff --git a/src/main/java/ast/AheadSensor.java b/src/main/java/ast/AheadSensor.java
index c7aea44..8aca256 100644
--- a/src/main/java/ast/AheadSensor.java
+++ b/src/main/java/ast/AheadSensor.java
@@ -21,7 +21,6 @@ public class AheadSensor extends Sensor
 
     public void changeExpr(Expr e)
     {
-        this.e.setParent(null);
         this.e = e;
         this.e.setParent(this);
     }
diff --git a/src/main/java/ast/BinaryCondition.java b/src/main/java/ast/BinaryCondition.java
index 9862c01..6cbf07c 100644
--- a/src/main/java/ast/BinaryCondition.java
+++ b/src/main/java/ast/BinaryCondition.java
@@ -50,7 +50,6 @@ public class BinaryCondition extends Condition
 
     public void changeLeft(Condition left)
     {
-        l.setParent(null);
         l = left;
         l.setParent(this);
     }
@@ -62,7 +61,6 @@ public class BinaryCondition extends Condition
 
     public void changeRight(Condition right)
     {
-        r.setParent(null);
         r = right;
         r.setParent(this);
     }
diff --git a/src/main/java/ast/BinaryOp.java b/src/main/java/ast/BinaryOp.java
index e3f70c2..380dc27 100644
--- a/src/main/java/ast/BinaryOp.java
+++ b/src/main/java/ast/BinaryOp.java
@@ -85,7 +85,6 @@ public class BinaryOp extends Expr
 
     public void changeLeft(Expr l)
     {
-        left.setParent(null);
         left = l;
         left.setParent(this);
     }
diff --git a/src/main/java/ast/Duplicate.java b/src/main/java/ast/Duplicate.java
index 98742de..9314953 100644
--- a/src/main/java/ast/Duplicate.java
+++ b/src/main/java/ast/Duplicate.java
@@ -84,12 +84,6 @@ public class Duplicate extends SearchMutation
         throw new UnsupportedOperationException();
     }
 
-    @Override
-    public void visit(Negative node)
-    {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void visit(NearbySensor node)
     {
@@ -121,7 +115,7 @@ public class Duplicate extends SearchMutation
         List<Node> children = node.getChildren();
         int size = children.size();
         Node lastChild = children.get(size - 1);
-        if (lastChild instanceof Action)
+        if (lastChild instanceof Action && subtrees.size() > 0)
         {
             int index = super.pickElement(subtrees);
             Update clone = (Update) (subtrees.get(index).clone());
@@ -129,7 +123,7 @@ public class Duplicate extends SearchMutation
             children.set(size - 1, clone);
             children.add(lastChild);
         }
-        else
+        else if (lastChild instanceof Update)
         {
             List<Node> actionSubtrees = super.findSubtrees(new Action(TokenType.WAIT));
             subtrees.addAll(actionSubtrees);
diff --git a/src/main/java/ast/Insert.java b/src/main/java/ast/Insert.java
index 5013a1a..d1a4c3d 100644
--- a/src/main/java/ast/Insert.java
+++ b/src/main/java/ast/Insert.java
@@ -145,12 +145,6 @@ public class Insert extends SearchMutation
         visitExpr(node);
     }
 
-    @Override
-    public void visit(Negative node)
-    {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void visit(NearbySensor node)
     {
diff --git a/src/main/java/ast/Mem.java b/src/main/java/ast/Mem.java
index 168d514..54f2d59 100644
--- a/src/main/java/ast/Mem.java
+++ b/src/main/java/ast/Mem.java
@@ -78,7 +78,8 @@ public class Mem extends Expr
     }
 
     @Override
-    public StringBuilder prettyPrint(StringBuilder sb) {
+    public StringBuilder prettyPrint(StringBuilder sb)
+    {
         sb.append("mem[");
         this.e.prettyPrint(sb);
         sb.append("]");
@@ -92,9 +93,8 @@ public class Mem extends Expr
 
     public void changeExpr(Expr e)
     {
-        this.e.setParent(null);
         this.e = e;
-        this.setParent(this);
+        e.setParent(this);
     }
 
     @Override
diff --git a/src/main/java/ast/NearbySensor.java b/src/main/java/ast/NearbySensor.java
index 8dd7796..d58bd39 100644
--- a/src/main/java/ast/NearbySensor.java
+++ b/src/main/java/ast/NearbySensor.java
@@ -1,5 +1,6 @@
 package ast;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public class NearbySensor extends Sensor
@@ -32,8 +33,9 @@ public class NearbySensor extends Sensor
     }
 
     @Override
-    public List<Node> getChildren() {
-        return null;
+    public List<Node> getChildren()
+    {
+        return new ArrayList<>();
     }
 
     @Override
diff --git a/src/main/java/ast/Negative.java b/src/main/java/ast/Negative.java
deleted file mode 100644
index 5130806..0000000
--- a/src/main/java/ast/Negative.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package ast;
-
-import java.util.List;
-
-public class Negative extends AbstractNode
-{
-    @Override
-    public List<Node> getChildren() {
-        return null;
-    }
-
-    @Override
-    public StringBuilder prettyPrint(StringBuilder sb) {
-        sb.append("-");
-        return sb;
-    }
-
-    @Override
-    public Node clone() {
-        return new Negative();
-    }
-
-    @Override
-    public NodeCategory getCategory() {
-        return null;
-    }
-
-    @Override
-    public void accept(Visitor v)
-    {
-        v.visit(this);
-    }
-
-
-    @Override
-    public boolean classInv()
-    {
-        return true;
-    }
-}
diff --git a/src/main/java/ast/NegativeExpr.java b/src/main/java/ast/NegativeExpr.java
index f3bed74..ac5a53d 100644
--- a/src/main/java/ast/NegativeExpr.java
+++ b/src/main/java/ast/NegativeExpr.java
@@ -5,31 +5,27 @@ import java.util.List;
 
 public class NegativeExpr extends Expr
 {
-    private Negative negativeNode;
     private Expr factor;
 
-    public NegativeExpr(Negative negativeNode, Expr factor)
+    public NegativeExpr(Expr factor)
     {
-        this.negativeNode = negativeNode;
         this.factor = factor;
-        this.negativeNode.setParent(this);
         this.factor.setParent(this);
     }
 
     @Override
-    public Node clone(){
-        Negative clonedNegativeNode =  (Negative) this.negativeNode.clone();
+    public Node clone()
+    {
         Expr clonedFactor =  (Expr) this.factor.clone();
-        NegativeExpr cloned = new NegativeExpr(clonedNegativeNode, clonedFactor);
-        clonedNegativeNode.setParent(cloned);
+        NegativeExpr cloned = new NegativeExpr(clonedFactor);
         clonedFactor.setParent(cloned);
         return cloned;
     }
 
     @Override
-    public List<Node> getChildren() {
+    public List<Node> getChildren()
+    {
         ArrayList<Node> children = new ArrayList<>();
-        children.add(negativeNode);
         children.add(factor);
         return children;
     }
@@ -37,17 +33,12 @@ public class NegativeExpr extends Expr
     @Override
     public StringBuilder prettyPrint(StringBuilder sb)
     {
-        negativeNode.prettyPrint(sb);
-        sb.append(" ");
+        sb.append("-");
+//        sb.append(" ");
         factor.prettyPrint(sb);
         return sb;
     }
 
-    public Negative getLeft()
-    {
-        return negativeNode;
-    }
-
     public Expr getRight()
     {
         return factor;
@@ -70,6 +61,6 @@ public class NegativeExpr extends Expr
     @Override
     public boolean classInv()
     {
-        return (negativeNode.classInv() && factor.classInv());
+        return factor.classInv();
     }
 }
diff --git a/src/main/java/ast/Number.java b/src/main/java/ast/Number.java
index ce8566c..9671724 100644
--- a/src/main/java/ast/Number.java
+++ b/src/main/java/ast/Number.java
@@ -1,5 +1,6 @@
 package ast;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public class Number extends Expr
@@ -35,7 +36,7 @@ public class Number extends Expr
     @Override
     public List<Node> getChildren()
     {
-        return null;
+        return new ArrayList<Node>();
     }
 
     @Override
diff --git a/src/main/java/ast/ProgramImpl.java b/src/main/java/ast/ProgramImpl.java
index 0db03aa..11c1f28 100644
--- a/src/main/java/ast/ProgramImpl.java
+++ b/src/main/java/ast/ProgramImpl.java
@@ -33,11 +33,14 @@ public class ProgramImpl extends AbstractNode implements Program
     @Override
     public StringBuilder prettyPrint(StringBuilder sb)
     {
-        for(Node child : getChildren())
+        List<Node> children = this.getChildren();
+        for(Node child : children)
         {
             child.prettyPrint(sb);
-            sb.append(";");
-            sb.append(System.lineSeparator());
+            if (child != children.get(children.size() - 1))
+            {
+                sb.append(System.lineSeparator());
+            }
         }
         return sb;
     }
@@ -82,8 +85,9 @@ public class ProgramImpl extends AbstractNode implements Program
     @Override
     public Program mutate()
     {
+        int size = this.size();
         int randomMut = (int)(Math.random() * 6);
-        int randomNode = (int)(Math.random() * this.size());
+        int randomNode = (int)(Math.random() * size);
         Mutation m;
 
         if(randomMut == 0)
@@ -116,6 +120,12 @@ public class ProgramImpl extends AbstractNode implements Program
             m = MutationFactory.getDuplicate();
         }
 
+        int count = 0;
+        while (!m.canApply(this.nodeAt(randomNode)) && count < size)
+        {
+            randomNode = (int)(Math.random() * size);
+            count++;
+        }
         m.apply(this, this.nodeAt(randomNode));
         return this;
     }
diff --git a/src/main/java/ast/Remove.java b/src/main/java/ast/Remove.java
index af7d5ca..0645b7d 100644
--- a/src/main/java/ast/Remove.java
+++ b/src/main/java/ast/Remove.java
@@ -29,7 +29,7 @@ public class Remove extends AbstractMutation
     public boolean canApply(Node n)
     {
         if (n instanceof ProgramImpl || n instanceof Relation || n instanceof Number
-                || n instanceof Negative || n instanceof SmellSensor || n instanceof Command)
+                || n instanceof SmellSensor || n instanceof Command)
         {
             return false;
         }
@@ -59,7 +59,6 @@ public class Remove extends AbstractMutation
         {
             parent.remove(node);
         }
-        node.setParent(null);
     }
 
     @Override
@@ -71,8 +70,6 @@ public class Remove extends AbstractMutation
         {
             Condition child = childPicker == 0 ? node.getLeft() : node.getRight();
             ((Rule) parent).changeCondition(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof BinaryCondition)
         {
@@ -85,8 +82,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryCondition) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
     }
 
@@ -112,8 +107,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryOp) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof Relation)
         {
@@ -126,15 +119,11 @@ public class Remove extends AbstractMutation
             {
                 ((Relation) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Update)
         {
             Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
             ((Update) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Action)
         {
@@ -142,8 +131,6 @@ public class Remove extends AbstractMutation
             {
                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
                 ((Action) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
 //            else
 //            {
@@ -154,8 +141,6 @@ public class Remove extends AbstractMutation
         {
             Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
             ((Mem) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Sensor)
         {
@@ -163,22 +148,16 @@ public class Remove extends AbstractMutation
             {
                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
                 ((NearbySensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof AheadSensor)
             {
                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
-                ((AheadSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
+                ((AheadSensor) parent).changeExpr(child);;
             }
             else if (parent instanceof RandomSensor)
             {
                 Expr child = childPicker == 0 ? node.getLeft() : node.getRight();
                 ((RandomSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
         }
     }
@@ -204,8 +183,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryOp) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof Relation)
         {
@@ -218,8 +195,6 @@ public class Remove extends AbstractMutation
             {
                 ((Relation) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Update)
         {
@@ -232,8 +207,6 @@ public class Remove extends AbstractMutation
             {
                 ((Update) parent).changeExpr(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Action)
         {
@@ -241,8 +214,6 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((Action) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
 //            else
 //            {
@@ -253,15 +224,11 @@ public class Remove extends AbstractMutation
         {
             Expr child = node.getExpr();
             ((Mem) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof NegativeExpr)
         {
             Expr child = node.getExpr();
             ((NegativeExpr) parent).changeRight(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Sensor)
         {
@@ -269,22 +236,16 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((NearbySensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof AheadSensor)
             {
                 Expr child = node.getExpr();
                 ((AheadSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof RandomSensor)
             {
                 Expr child = node.getExpr();
                 ((RandomSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
         }
     }
@@ -304,8 +265,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryOp) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof Relation)
         {
@@ -318,15 +277,11 @@ public class Remove extends AbstractMutation
             {
                 ((Relation) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Update)
         {
             Expr child = node.getRight();
             ((Update) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Action)
         {
@@ -334,8 +289,6 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getRight();
                 ((Action) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
 //            else
 //            {
@@ -346,15 +299,11 @@ public class Remove extends AbstractMutation
         {
             Expr child = node.getRight();
             ((Mem) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof NegativeExpr)
         {
             Expr child = node.getRight();
             ((NegativeExpr) parent).changeRight(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Sensor)
         {
@@ -362,32 +311,20 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getRight();
                 ((NearbySensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof AheadSensor)
             {
                 Expr child = node.getRight();
                 ((AheadSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof RandomSensor)
             {
                 Expr child = node.getRight();
                 ((RandomSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
         }
     }
 
-    @Override
-    public void visit(Negative node)
-    {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void visit(NearbySensor node)
     {
@@ -403,8 +340,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryOp) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof Relation)
         {
@@ -417,15 +352,11 @@ public class Remove extends AbstractMutation
             {
                 ((Relation) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Update)
         {
             Expr child = node.getExpr();
             ((Update) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Action)
         {
@@ -433,8 +364,6 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((Action) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
 //            else
 //            {
@@ -445,15 +374,11 @@ public class Remove extends AbstractMutation
         {
             Expr child = node.getExpr();
             ((Mem) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof NegativeExpr)
         {
             Expr child = node.getExpr();
             ((NegativeExpr) parent).changeRight(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Sensor)
         {
@@ -461,22 +386,16 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((NearbySensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof AheadSensor)
             {
                 Expr child = node.getExpr();
                 ((AheadSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof RandomSensor)
             {
                 Expr child = node.getExpr();
                 ((RandomSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
         }
     }
@@ -496,8 +415,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryOp) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof Relation)
         {
@@ -510,15 +427,11 @@ public class Remove extends AbstractMutation
             {
                 ((Relation) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Update)
         {
             Expr child = node.getExpr();
             ((Update) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Action)
         {
@@ -526,8 +439,6 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((Action) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
 //            else
 //            {
@@ -538,15 +449,11 @@ public class Remove extends AbstractMutation
         {
             Expr child = node.getExpr();
             ((Mem) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof NegativeExpr)
         {
             Expr child = node.getExpr();
             ((NegativeExpr) parent).changeRight(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Sensor)
         {
@@ -554,22 +461,16 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((NearbySensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof AheadSensor)
             {
                 Expr child = node.getExpr();
                 ((AheadSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof RandomSensor)
             {
                 Expr child = node.getExpr();
                 ((RandomSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
         }
     }
@@ -589,8 +490,6 @@ public class Remove extends AbstractMutation
             {
                 ((BinaryOp) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         if (parent instanceof Relation)
         {
@@ -603,15 +502,11 @@ public class Remove extends AbstractMutation
             {
                 ((Relation) parent).changeRight(child);
             }
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Update)
         {
             Expr child = node.getExpr();
             ((Update) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Action)
         {
@@ -619,8 +514,6 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((Action) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
 //            else
 //            {
@@ -631,15 +524,11 @@ public class Remove extends AbstractMutation
         {
             Expr child = node.getExpr();
             ((Mem) parent).changeExpr(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof NegativeExpr)
         {
             Expr child = node.getExpr();
             ((NegativeExpr) parent).changeRight(child);
-            child.setParent(parent);
-            node.setParent(null);
         }
         else if (parent instanceof Sensor)
         {
@@ -647,22 +536,16 @@ public class Remove extends AbstractMutation
             {
                 Expr child = node.getExpr();
                 ((NearbySensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof AheadSensor)
             {
                 Expr child = node.getExpr();
                 ((AheadSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
             else if (parent instanceof RandomSensor)
             {
                 Expr child = node.getExpr();
                 ((RandomSensor) parent).changeExpr(child);
-                child.setParent(parent);
-                node.setParent(null);
             }
         }
     }
@@ -686,7 +569,6 @@ public class Remove extends AbstractMutation
         if (((Command) parent).getChildren().size() > 1)
         {
             ((Command) parent).remove(node);
-            node.setParent(null);
         }
     }
 
@@ -697,7 +579,6 @@ public class Remove extends AbstractMutation
         if (((Command) parent).getChildren().size() > 1)
         {
             ((Command) parent).remove(node);
-            node.setParent(null);
         }
     }
 }
diff --git a/src/main/java/ast/Replace.java b/src/main/java/ast/Replace.java
index 60ea270..2358920 100644
--- a/src/main/java/ast/Replace.java
+++ b/src/main/java/ast/Replace.java
@@ -29,7 +29,7 @@ public class Replace extends SearchMutation
     @Override
     public boolean canApply(Node n)
     {
-        return !(n instanceof ProgramImpl || n instanceof Negative);
+        return !(n instanceof ProgramImpl);
     }
 
     @Override
@@ -47,8 +47,6 @@ public class Replace extends SearchMutation
         Node parent = node.getParent();
         Rule clone = (Rule) (replacementNode.clone());
         ((ProgramImpl) parent).replace(node, clone);
-        clone.setParent(parent);
-        node.setParent(null);
     }
 
     @Override
@@ -59,8 +57,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Condition clone = (Condition) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof Rule)
         {
             ((Rule) parent).changeCondition(clone);
@@ -86,8 +82,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Condition clone = (Condition) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof Rule)
         {
             ((Rule) parent).changeCondition(clone);
@@ -112,9 +106,7 @@ public class Replace extends SearchMutation
         int index = super.pickElement(subtrees);
         Node replacementNode = subtrees.get(index);
         Node parent = node.getParent();
-        node.setParent(null);
         Expr clone = (Expr) (replacementNode.clone());
-        clone.setParent(parent);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -181,8 +173,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -249,8 +239,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -283,10 +271,8 @@ public class Replace extends SearchMutation
                         iter.remove();
                     }
                 }
-                clone.setParent(null);
                 index = super.pickElement(subtrees);
                 Mem newClone = (Mem) (subtrees.get(index));
-                newClone.setParent(parent);
                 ((Update) parent).changeMemType(newClone);
             }
             else
@@ -334,8 +320,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -394,12 +378,6 @@ public class Replace extends SearchMutation
         }
     }
 
-    @Override
-    public void visit(Negative node)
-    {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void visit(NearbySensor node)
     {
@@ -408,8 +386,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -476,8 +452,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -544,8 +518,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -612,8 +584,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Expr clone = (Expr) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         if (parent instanceof BinaryOp)
         {
             if (node == ((BinaryOp) parent).getLeft())
@@ -680,8 +650,10 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Command clone = (Command) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
+        if (parent == null)
+        {
+            System.out.println("parent is null");
+        }
         ((Rule) parent).changeCommand(clone);
     }
 
@@ -693,8 +665,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Update clone = (Update) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         ((Command) parent).replace(node, clone);
     }
 
@@ -706,8 +676,6 @@ public class Replace extends SearchMutation
         Node replacementNode = subtrees.get(index);
         Action clone = (Action) (replacementNode.clone());
         Node parent = node.getParent();
-        clone.setParent(parent);
-        node.setParent(null);
         ((Command) parent).replace(node, clone);
     }
 }
diff --git a/src/main/java/ast/Rule.java b/src/main/java/ast/Rule.java
index 3efc40c..ec02d1d 100644
--- a/src/main/java/ast/Rule.java
+++ b/src/main/java/ast/Rule.java
@@ -32,6 +32,7 @@ public class Rule extends AbstractNode {
         condition.prettyPrint(sb);
         sb.append((" --> "));
         command.prettyPrint(sb);
+        sb.append(";");
 
         return sb;
     }
@@ -69,7 +70,8 @@ public class Rule extends AbstractNode {
     }
 
     @Override
-    public NodeCategory getCategory() {
+    public NodeCategory getCategory()
+    {
         return NodeCategory.RULE;
     }
 
diff --git a/src/main/java/ast/SmellSensor.java b/src/main/java/ast/SmellSensor.java
index 958b238..e107488 100644
--- a/src/main/java/ast/SmellSensor.java
+++ b/src/main/java/ast/SmellSensor.java
@@ -1,5 +1,7 @@
 package ast;
 
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 public class SmellSensor extends Sensor
@@ -18,7 +20,7 @@ public class SmellSensor extends Sensor
 
     @Override
     public List<Node> getChildren() {
-        return null;
+        return new ArrayList<>();
     }
 
     @Override
diff --git a/src/main/java/ast/Swap.java b/src/main/java/ast/Swap.java
index 2cca601..214bc4e 100644
--- a/src/main/java/ast/Swap.java
+++ b/src/main/java/ast/Swap.java
@@ -114,12 +114,6 @@ public class Swap extends AbstractMutation
         throw new UnsupportedOperationException();
     }
 
-    @Override
-    public void visit(Negative node)
-    {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void visit(NearbySensor node)
     {
@@ -154,20 +148,20 @@ public class Swap extends AbstractMutation
             int childPicker2;
             if (children.get(children.size() - 1) instanceof Action)
             {
-                childPicker1 = (int) (Math.random() * children.size());
-                childPicker2 = (int) (Math.random() * children.size());
+                childPicker1 = (int) (Math.random() * children.size() - 1);
+                childPicker2 = (int) (Math.random() * children.size() - 1);
             }
             else
             {
-                childPicker1 = (int) (Math.random() * (children.size() - 1));
-                childPicker2 = (int) (Math.random() * (children.size() - 1));
+                childPicker1 = (int) (Math.random() * (children.size()));
+                childPicker2 = (int) (Math.random() * (children.size()));
             }
             while (childPicker1 == childPicker2)
             {
                 childPicker2 = (int) (Math.random() * node.getChildren().size());
             }
-            Node temp = node.getChildren().get(childPicker1);
-            Node temp2 = node.getChildren().get(childPicker2);
+            Node temp = children.get(childPicker1);
+            Node temp2 = children.get(childPicker2);
             node.getChildren().set(childPicker1, temp2);
             node.getChildren().set(childPicker2, temp);
         }
diff --git a/src/main/java/ast/Transform.java b/src/main/java/ast/Transform.java
index 4188762..5e67d9d 100644
--- a/src/main/java/ast/Transform.java
+++ b/src/main/java/ast/Transform.java
@@ -137,12 +137,6 @@ public class Transform extends AbstractMutation
         throw new UnsupportedOperationException();
     }
 
-    @Override
-    public void visit(Negative node)
-    {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void visit(NearbySensor node)
     {
diff --git a/src/main/java/ast/Visitor.java b/src/main/java/ast/Visitor.java
index a0d6ca9..16a0770 100644
--- a/src/main/java/ast/Visitor.java
+++ b/src/main/java/ast/Visitor.java
@@ -18,8 +18,6 @@ public interface Visitor
 
     void visit(NegativeExpr node);
 
-    void visit(Negative node);
-
     void visit(NearbySensor node);
 
     void visit(AheadSensor node);
diff --git a/src/main/java/console/Console.java b/src/main/java/console/Console.java
new file mode 100644
index 0000000..054ea64
--- /dev/null
+++ b/src/main/java/console/Console.java
@@ -0,0 +1,147 @@
+package console;
+
+import cms.util.maybe.Maybe;
+import controller.Controller;
+import controller.ControllerFactory;
+import java.util.Arrays;
+import java.util.Scanner;
+import java.util.stream.Collectors;
+import model.ReadOnlyCritter;
+import model.ReadOnlyWorld;
+
+/**
+ * The provided shows you how the course staff may call the methods in Controller to test your code.
+ *
+ * <p>You don't need to modify anything in this file. You can choose to make it prettier, but you
+ * still need to support the same set of commands and print out the same set of information.
+ *
+ * <p>NEVER remove this file, since it will be your entry point of the JAR file.
+ */
+public final class Console
+{
+    private final Controller controller = ControllerFactory.getConsoleController();
+    private final Scanner scan = new Scanner(System.in);
+
+    private Console() {}
+
+    /* =========================== */
+    /* DO NOT EDIT ABOVE THIS LINE */
+    /* (except imports...) */
+    /* =========================== */
+
+    /** Prints current time step, number of critters, and world map of the simulation. */
+    private void worldInfo() {
+        ReadOnlyWorld world = controller.getReadOnlyWorld();
+        System.out.println("steps: " + world.getSteps());
+        System.out.println("critters: " + world.getNumberOfAliveCritters());
+        controller.printWorld(System.out);
+    }
+
+    /**
+     * Prints description of the contents of hex (c,r).
+     *
+     * @param c column of hex
+     * @param r row of hex
+     */
+    private void hexInfo(int c, int r) {
+        ReadOnlyWorld world = controller.getReadOnlyWorld();
+        Maybe<ReadOnlyCritter> maybeCritter = world.getReadOnlyCritter(c, r);
+        maybeCritter.thenElse(critter -> {
+            System.out.println("Species: " + critter.getSpecies());
+            String memory =
+                    Arrays.stream(critter.getMemory())
+                            .mapToObj(String::valueOf)
+                            .collect(Collectors.joining(" "));
+            System.out.println("Memory:" + memory);
+            System.out.println("Program: " + critter.getProgramString());
+            System.out.println("Last rule: " + critter.getLastRuleString());
+        }, () -> {
+            int terrain = world.getTerrainInfo(c, r);
+            if (terrain == 0) {
+                System.out.println("Empty");
+            } else if (terrain == -1) {
+                System.out.println("Rock");
+            } else if (terrain > 0){
+                System.out.println("Critter");
+            } else {
+                System.out.println("Food: " + (-terrain - 1));
+            }
+        });
+    }
+
+    /* =========================== */
+    /* DO NOT EDIT BELOW THIS LINE */
+    /* =========================== */
+
+    /** Prints a list of possible commands to the standard output. */
+    private void printHelp() {
+        System.out.println("new: start a new simulation with a random world");
+        System.out.println(
+                "load <world_file>: start a new simulation with the world loaded from world_file");
+        System.out.println(
+                "critters <critter_file> <n>: add n critters defined by critter_file randomly into the world");
+        System.out.println("step <n>: advance the world by n timesteps");
+        System.out.println(
+                "info: print current timestep, number of critters living, and map of world");
+        System.out.println("hex <c> <r>: print contents of hex at column c, row r");
+        System.out.println("exit: exit the program");
+    }
+
+    /**
+     * Processes a single console command provided by the user.
+     *
+     * @return whether we should continue handling commands.
+     */
+    private boolean handleCommand() {
+        System.out.print("Enter a command or \"help\" for a list of commands.\n> ");
+        String command = scan.next();
+        switch (command) {
+            case "new":
+                controller.newWorld();
+                break;
+            case "load":
+                {
+                    String filename = scan.next();
+                    controller.loadWorld(filename, true, false);
+                    break;
+                }
+            case "critters":
+                {
+                    String filename = scan.next();
+                    int n = scan.nextInt();
+                    controller.loadCritters(filename, n);
+                    break;
+                }
+            case "step":
+                {
+                    int n = scan.nextInt();
+                    controller.advanceTime(n);
+                    break;
+                }
+            case "info":
+                worldInfo();
+                break;
+            case "hex":
+                {
+                    int c = scan.nextInt();
+                    int r = scan.nextInt();
+                    hexInfo(c, r);
+                    break;
+                }
+            case "help":
+                printHelp();
+                break;
+            case "exit":
+                return false;
+            default:
+                System.out.println(command + " is not a valid command.");
+        }
+        return true;
+    }
+
+    public static void main(String[] args)
+    {
+        Console console = new Console();
+        while (console.handleCommand()) ;
+    }
+}
diff --git a/src/main/java/controller/Controller.java b/src/main/java/controller/Controller.java
new file mode 100644
index 0000000..55372f7
--- /dev/null
+++ b/src/main/java/controller/Controller.java
@@ -0,0 +1,59 @@
+package controller;
+
+import java.io.PrintStream;
+import model.ReadOnlyWorld;
+
+/**
+ * Controller interface that allows the course staff to test your critter world implementation.
+ *
+ * <p>NEVER remove or change any methods in this file except reformatting. Feel free to add
+ * additional methods in this file. It might be helpful in later assignments.
+ *
+ * <p>You have to provide one implementation of {@code ConsoleController} to {@code
+ * ControllerFactory}.
+ */
+public interface Controller
+{
+    /** @return the readonly world. */
+    ReadOnlyWorld getReadOnlyWorld();
+
+    /** Starts new random world simulation. */
+    void newWorld();
+
+    /**
+     * Starts new simulation with world specified in filename.
+     *
+     * @param filename name of the world file.
+     * @param enableManna if enableManna is false, then the world should not drop any manna.
+     * This is important for deterministic unit testing.
+     * @param enableForcedMutation if enableForcedMutation is true, then a critter's program
+     * will mutate every time it finishes its action.
+     * @return whether the world is successfully loaded.
+     */
+    boolean loadWorld(String filename, boolean enableManna, boolean enableForcedMutation);
+
+    /**
+     * Loads critter definition from filename and randomly places n critters with that definition
+     * into the world.
+     *
+     * @param filename name of the critter spec file.
+     * @param n number of critter to add.
+     * @return whether all critters are successfully loaded.
+     */
+    boolean loadCritters(String filename, int n);
+
+    /**
+     * Advances the world by n time steps.
+     *
+     * @param n number of steps.
+     * @return false if the world has not been initialized or n is negative, true otherwise.
+     */
+    boolean advanceTime(int n);
+
+    /**
+     * Print the world to the specified stream.
+     *
+     * @param out the stream to print the world.
+     */
+    void printWorld(PrintStream out);
+}
diff --git a/src/main/java/controller/ControllerFactory.java b/src/main/java/controller/ControllerFactory.java
new file mode 100644
index 0000000..377d319
--- /dev/null
+++ b/src/main/java/controller/ControllerFactory.java
@@ -0,0 +1,21 @@
+package controller;
+
+/** DO NOT REMOVE ANY METHODS IN THIS CLASS. Course staff needs this to test your world. */
+public final class ControllerFactory
+{
+
+    /**
+     * Private constructor can prevent any {@code new ControllerFactory()} since they do not make
+     * sense.
+     */
+    private ControllerFactory() {}
+
+    /**
+     * @return a controller for console to allow course staff to test your code. The returned
+     *     controller contains a randomly initialized world.
+     */
+    public static Controller getConsoleController()
+    {
+        return new ControllerImpl();
+    }
+}
diff --git a/src/main/java/controller/ControllerImpl.java b/src/main/java/controller/ControllerImpl.java
new file mode 100644
index 0000000..9f9298d
--- /dev/null
+++ b/src/main/java/controller/ControllerImpl.java
@@ -0,0 +1,233 @@
+package controller;
+
+import ast.Program;
+import exceptions.SyntaxError;
+import model.*;
+import parse.Parser;
+import parse.ParserFactory;
+
+import java.io.FileNotFoundException;
+import java.io.PrintStream;
+import java.io.File;
+import java.io.Reader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Scanner;
+
+public class ControllerImpl implements Controller
+{
+    private ControlOnlyWorld controlWorld;
+    private ReadOnlyWorld readOnlyWorld;
+    private boolean enableManna;
+    private boolean enableForcedMutation;
+
+    @Override
+    public ReadOnlyWorld getReadOnlyWorld()
+    {
+        return readOnlyWorld;
+    }
+
+    @Override
+    public void newWorld()
+    {
+        World world = new World();
+        controlWorld = world;
+        readOnlyWorld = world;
+    }
+
+    @Override
+    public boolean loadWorld(String filename, boolean enableManna, boolean enableForcedMutation)
+    {
+        this.enableManna = enableManna;
+        this.enableForcedMutation = enableForcedMutation;
+
+        File worldFile = new File(filename);
+        try
+        {
+            Scanner sc = new Scanner(worldFile);
+            sc.next();
+            System.out.println(sc.nextLine().substring(1));
+            sc.next();
+            int width = sc.nextInt();
+            int height = sc.nextInt();
+            World world = new World(width, height, enableManna, enableForcedMutation);
+            controlWorld = world;
+            readOnlyWorld = world;
+            while (sc.hasNext())
+            {
+                String object = sc.next();
+                if (object.startsWith("//"))
+                {
+                    sc.nextLine();
+                }
+                else if (object.equals("rock"))
+                {
+                    int column = sc.nextInt();
+                    int row = sc.nextInt();
+                    controlWorld.addRock(row, column);
+                }
+                else if (object.equals("food"))
+                {
+                    int column = sc.nextInt();
+                    int row = sc.nextInt();
+                    int amount = sc.nextInt();
+                    controlWorld.addFood(row, column, amount);
+                }
+                else if (object.equals("critter"))
+                {
+                    String critterFile = sc.next();
+                    int column = sc.nextInt();
+                    int row = sc.nextInt();
+                    int direction = sc.nextInt();
+                    if ((row + column) % 2 == 0)
+                    {
+                        Object[] critterInfo = parseCritterFile(worldFile.getParent() + "\\" + critterFile);
+//                    System.out.println(Arrays.toString(critterInfo));
+                        if (critterInfo != null)
+                        {
+                            controlWorld.addCritter((String) critterInfo[0], (int[]) critterInfo[1], (Program) critterInfo[2],
+                                    row, column, direction);
+                        }
+                    }
+                }
+            }
+
+            world.addFood(20, 20, 1000);
+
+            return true;
+        }
+        catch (FileNotFoundException e)
+        {
+            System.out.println("please input a valid world file");
+        }
+        return false;
+    }
+
+    @Override
+    public boolean loadCritters(String filename, int n)
+    {
+        Object[] critterInfo = parseCritterFile(filename);
+        if (critterInfo != null)
+        {
+            for (int i = 0; i < n; i++)
+            {
+                controlWorld.addCritter((String) critterInfo[0], (int[]) critterInfo[1], (Program) critterInfo[2]);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean advanceTime(int n)
+    {
+        if (controlWorld == null || n < 0)
+        {
+            return false;
+        }
+        for (int i = 0; i < n; i++)
+        {
+            controlWorld.advanceTimeStep();
+            if(enableForcedMutation) controlWorld.forcedMutate();
+            if(enableManna) controlWorld.addManna();
+        }
+
+        return true;
+    }
+
+    @Override
+    public void printWorld(PrintStream out)
+    {
+        controlWorld.printWorld(out);
+    }
+
+    public Object[] parseCritterFile(String filename)
+    {
+        try
+        {
+//            System.out.println(filename);
+            Reader r = new FileReader(filename);
+//            System.out.println("passed 1");
+            String species = "";
+            Program ast;
+            int[] mem = new int[Constants.MIN_MEMORY];
+//            int row;
+//            int column;
+//            int direction;
+            int line = 1;
+            String text = "";
+            while (line <= 7)
+            {
+                text = "";
+                int i;
+                while ((char) (i = r.read()) != '\n')
+                {
+                    text += (char) i;
+                }
+                if (text.endsWith("\r"))
+                {
+                    text = text.substring(0, text.length() - 1);
+                }
+//                System.out.println(text + ", line " + line);
+                if (text.startsWith("//") || text.equals(""))
+                {
+                    continue;
+                }
+                else if (text.startsWith("species: ") && line == 1)
+                {
+                    species = text.substring(9);
+                }
+                else if (text.startsWith("memsize: ") && line == 2)
+                {
+                    int memsize = Integer.parseInt(text.substring(9));
+                    mem = memsize > Constants.MIN_MEMORY ? new int[memsize] : mem;
+                    mem[0] = memsize;
+                    mem[5] = 1;
+                }
+                else if (text.startsWith("defense: ") && line == 3)
+                {
+                    int num = Integer.parseInt(text.substring(9));
+                    mem[1] = num;
+                }
+                else if (text.startsWith("offense: ") && line == 4)
+                {
+                    int num = Integer.parseInt(text.substring(9));
+                    mem[2] = num;
+                }
+                else if (text.startsWith("size: ") && line == 5)
+                {
+                    int num = Integer.parseInt(text.substring(6));
+                    mem[3] = num;
+                }
+                else if (text.startsWith("energy: ") && line == 6)
+                {
+                    int num = Integer.parseInt(text.substring(8));
+                    mem[4] = num;
+                }
+                else if (text.startsWith("posture: ") && line == 7)
+                {
+                    int num = Integer.parseInt(text.substring(9));
+                    mem[6] = num;
+                }
+                else
+                {
+                    throw new IOException();
+                }
+                line++;
+            }
+            Parser p = ParserFactory.getParser();
+            ast = p.parse(r);
+            return new Object[]{species, mem, ast};
+        }
+        catch (IOException e)
+        {
+            System.out.println("please input a valid critter file");
+        }
+        catch (SyntaxError e)
+        {
+            System.out.println("a valid program should not have syntax errors");;
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/main/ParseAndMutateApp.java b/src/main/java/main/ParseAndMutateApp.java
index 1a4fd17..7fafdaf 100644
--- a/src/main/java/main/ParseAndMutateApp.java
+++ b/src/main/java/main/ParseAndMutateApp.java
@@ -74,6 +74,7 @@ public class ParseAndMutateApp
                         while (!(mut.canApply(target)) && count < 50)
                         {
                             target = prog.nodeAt((int) (Math.random() * prog.size()));
+                            count++;
                         }
                         mut.apply(prog, target);
                         System.out.println(mut.getClass());
diff --git a/src/main/java/model/Constants.java b/src/main/java/model/Constants.java
new file mode 100644
index 0000000..76db64c
--- /dev/null
+++ b/src/main/java/model/Constants.java
@@ -0,0 +1,32 @@
+package model;
+
+/**
+ * NEVER remove or change any constants in this file except reformatting. Feel free to add
+ * additional constants in this file.
+ */
+public final class Constants {
+
+    private Constants() {}
+
+    public static final int BASE_DAMAGE = 100;
+    public static final double DAMAGE_INC = .2;
+    public static final int ENERGY_PER_SIZE = 500;
+    public static final int FOOD_PER_SIZE = 200;
+    public static final int MAX_SMELL_DISTANCE = 10;
+    public static final int ROCK_VALUE = -1;
+    public static final int WIDTH = 50;
+    public static final int HEIGHT = 87;
+    public static final int MAX_RULES_PER_TURN = 999;
+    public static final int SOLAR_FLUX = 1;
+    public static final int MOVE_COST = 3;
+    public static final int ATTACK_COST = 5;
+    public static final int GROW_COST = 1;
+    public static final int BUD_COST = 9;
+    public static final int MATE_COST = 5;
+    public static final int RULE_COST = 2;
+    public static final int ABILITY_COST = 25;
+    public static final int INITIAL_ENERGY = 250;
+    public static final int MIN_MEMORY = 7;
+    public static final int MANNA_COUNT = 10;
+    public static final int MANNA_AMOUNT = 10;
+}
diff --git a/src/main/java/model/ControlOnlyWorld.java b/src/main/java/model/ControlOnlyWorld.java
new file mode 100644
index 0000000..75de5a1
--- /dev/null
+++ b/src/main/java/model/ControlOnlyWorld.java
@@ -0,0 +1,25 @@
+package model;
+
+import ast.Program;
+
+import java.io.PrintStream;
+
+public abstract class ControlOnlyWorld
+{
+    public abstract boolean addCritter(String species, int[] mem, Program ast);
+
+    public abstract boolean addCritter(String species, int[] mem, Program ast, int row, int column, int dir);
+
+    public abstract boolean addRock(int row, int column);
+
+    public abstract boolean addFood(int row, int column, int amount);
+
+    public abstract void advanceTimeStep();
+
+    public abstract void printWorld(PrintStream out);
+
+    public abstract void forcedMutate();
+
+    public abstract void addManna();
+
+}
diff --git a/src/main/java/model/Critter.java b/src/main/java/model/Critter.java
new file mode 100644
index 0000000..c5f9672
--- /dev/null
+++ b/src/main/java/model/Critter.java
@@ -0,0 +1,144 @@
+package model;
+
+import ast.Program;
+import cms.util.maybe.Maybe;
+
+public class Critter implements ReadOnlyCritter
+{
+    private String species;
+    private Program ast;
+    private int[] mem;
+    private int row;
+    private int column;
+    private int direction;
+    private String lastRuleString;
+    private boolean mating;
+    private boolean justCreated;
+
+    public Critter(String species, Program ast, int[] mem, int row, int column, int direction)
+    {
+        this.species = species;
+        this.ast = ast;
+        this.mem = mem;
+        this.row = row;
+        this.column = column;
+        this.direction = direction % 6 >= 0 ? direction % 6 : direction % 6 + 6; // idk if we should the mod 6 should be included
+        this.justCreated = true;
+    }
+
+    public Program getProgram()
+    {
+        return ast;
+    }
+
+//    public int[] getMem()
+//    {
+//        return mem;
+//    }
+
+    public boolean isMating()
+    {
+        return mating;
+    }
+
+    public boolean isJustCreated() {
+        return justCreated;
+    }
+
+    public void setJustcreated(boolean temp){
+        justCreated = temp;
+    }
+
+    public void setLastRuleString(String newRule)
+    {
+        lastRuleString = newRule;
+    }
+
+
+    public void setMating(boolean mating)
+    {
+        this.mating = mating;
+    }
+
+    public int getRow()
+    {
+        return row;
+    }
+
+    public int getColumn()
+    {
+        return column;
+    }
+
+    public void setPosition(int r, int c){
+        row = r;
+        column = c;
+    }
+
+    public void setDirection(int newDir){
+        direction = newDir;
+    }
+
+    public int energyCapacity(){
+        return mem[3] *  Constants.ENERGY_PER_SIZE;
+    }
+
+    public int complexity(){
+        return ast.getChildren().size() * Constants.RULE_COST + (mem[1] + mem[2]) * Constants.ABILITY_COST;
+    }
+
+    public int getDirection()
+    {
+        return direction;
+    }
+
+    public int getMemValue(int index)
+    {
+        return index >= 0 && index < mem.length ? mem[index] : 0;
+    }
+
+    public void setMem(int index, int newNum)
+    {
+        if ((index >= 3 && index <= 5 && newNum >= 1) || (index == 6 && newNum >= 0 && newNum <= 99) || (index >= 7 && index < mem.length))
+        {
+            mem[index] = newNum;
+        }
+    }
+
+    @Override
+    public String getSpecies()
+    {
+        return species;
+    }
+
+    @Override
+    public int[] getMemory()
+    {
+        return mem.clone();
+    }
+
+    @Override
+    public String getProgramString()
+    {
+        return ast.toString();
+    }
+
+    @Override
+    public Maybe<String> getLastRuleString()
+    {
+        return lastRuleString != null ? Maybe.from(lastRuleString) : Maybe.none();
+    }
+
+    @Override
+    public String toString()
+    {
+        String ret = "";
+        for(int i = 0; i<mem.length; i++)
+        {
+            ret += (mem[i] + ", ");
+        }
+        ret += (row + ", " + column + ", " + direction);
+        return ret;
+
+    }
+}
diff --git a/src/main/java/model/CritterAction.java b/src/main/java/model/CritterAction.java
new file mode 100644
index 0000000..cd6334d
--- /dev/null
+++ b/src/main/java/model/CritterAction.java
@@ -0,0 +1,703 @@
+package model;
+
+import ast.*;
+import parse.TokenType;
+
+public class CritterAction
+{
+    private World world;
+    private Critter critter;
+
+    public CritterAction (World world, Critter critter)
+    {
+        this.world = world;
+        this.critter = critter;
+    }
+
+    public boolean perform(TokenType action)
+    {
+        String name = action.toString();
+        switch(name)
+        {
+            case ("wait"):
+                return waitTurn();
+            case ("forward"):
+                return move(true);
+            case ("back"):
+                return move(false);
+            case ("left"):
+                return turn(true);
+            case ("right"):
+                return turn(false);
+            case ("eat"):
+                return eat();
+            case ("attack"):
+                return attack();
+            case ("grow"):
+                return grow();
+            case ("bud"):
+                return bud();
+            case ("mate"):
+                return mate();
+            default:
+                return false;
+        }
+    }
+
+    public boolean waitTurn()
+    {
+        critter.setMem(4, critter.getMemValue(4 ) + critter.getMemValue(3) * Constants.SOLAR_FLUX);
+        return true;
+    }
+    public boolean move (boolean direction){ //direction here refers to forwards (true) or backwards (false)
+
+        Tile[][] tiles = world.getTiles();
+        int r = critter.getRow();
+        int c = critter.getColumn();
+        int energySpent = critter.getMemValue(3) * Constants.MOVE_COST;
+
+        if(critter.getMemValue(4) < energySpent) {
+            world.deadCritter(critter);
+            return false;
+        }
+
+        if(direction){
+            switch(critter.getDirection())
+            {
+                case 0:
+                    c = c;
+                    r = r - 2;
+                    break;
+                case 1:
+                    c = c + 1;
+                    r = r - 1;
+                    break;
+                case 2:
+                    c = c + 1;
+                    r = r + 1;
+                    break;
+                case 3:
+                    c = c;
+                    r = r + 2;
+                    break;
+                case 4:
+                    c = c - 1;
+                    r = r + 1;
+                    break;
+                case 5:
+                    c = c - 1;
+                    r = r - 1;
+                    break;
+            }
+        }
+
+        else
+        {
+            switch(critter.getDirection())
+            {
+                case 0:
+                    c = c;
+                    r = r + 2;
+                    break;
+                case 1:
+                    c = c - 1;
+                    r = r + 1;
+                    break;
+                case 2:
+                    c = c - 1;
+                    r = r - 1;
+                    break;
+                case 3:
+                    c = c;
+                    r = r - 2;
+                    break;
+                case 4:
+                    c = c + 1;
+                    r = r - 1;
+                    break;
+                case 5:
+                    c = c + 1;
+                    r = r + 1;
+                    break;
+            }
+        }
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length)
+        {
+            if (critter.getMemValue(4) < energySpent) world.deadCritter(critter);
+            return false;
+        }
+
+        if( tiles[tiles.length - 1 - r][c] != null)
+        {
+            if (tiles[tiles.length - 1 - r][c].getIsRock()
+                        || tiles[tiles.length - 1 - r][c].getIsFood() || tiles[tiles.length - 1 - r][c].getIsCritter())
+            {
+                if (critter.getMemValue(4) < energySpent) world.deadCritter(critter);
+                return false;
+            }
+        }
+
+        else
+        {
+            world.setCritterPosition(critter, r, c);
+            if(critter.getMemValue(4) < energySpent) world.deadCritter(critter);
+
+            return true;
+        }
+
+        return false;
+    }
+    public boolean turn (boolean orientation){ //true is left, false is right
+
+        int newDir = critter.getDirection();
+
+        if(critter.getMemValue(4) < critter.getMemValue(3)){
+
+            world.deadCritter(critter);
+            return false;
+        }
+
+        else if(critter.getMemValue(4) == critter.getMemValue(3)){
+
+            if(orientation){
+                newDir += 5;
+            }
+            else{
+                newDir += 1;
+            }
+            newDir %= 6;
+            critter.setDirection(newDir);
+            world.deadCritter(critter);
+            return true;
+        }
+
+        else if(critter.getMemValue(4) > critter.getMemValue(3)){
+
+            if(orientation){
+                newDir += 5;
+                newDir %= 6;
+                critter.setDirection(newDir);
+            }
+            else{
+                newDir += 1;
+                newDir %= 6;
+                critter.setDirection(newDir);
+            }
+
+            critter.setMem(4, critter.getMemValue(4) - critter.getMemValue(3));
+
+            return true;
+        }
+
+        return false;
+    }
+
+    public boolean eat()
+    {
+        int energyBefore = critter.getMemValue(4);
+        if(energyBefore >= critter.energyCapacity()) return false;
+
+
+        Tile[][] tiles = world.getTiles();
+        int r = critter.getRow();
+        int c = critter.getColumn();
+        switch(critter.getDirection()){
+            case 0:
+                c = c;
+                r = r - 2;
+                break;
+            case 1:
+                c = c + 1;
+                r = r - 1;
+                break;
+            case 2:
+                c = c + 1;
+                r = r + 1;
+                break;
+            case 3:
+                c = c;
+                r = r + 2;
+                break;
+            case 4:
+                c = c - 1;
+                r = r + 1;
+                break;
+            case 5:
+                c = c - 1;
+                r = r - 1;
+                break;
+        }
+
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length
+                && (tiles[tiles.length - 1 - r][c] != null && !tiles[tiles.length - 1 - r][c].getIsFood())) return false;
+
+
+        int food;
+        if(tiles[r][c] == null) food = 0;
+        else food = tiles[r][c].getNumFood();
+
+        if(energyBefore + food <= critter.energyCapacity()){
+            critter.setMem(4, energyBefore + food);
+            tiles[r][c] = null;
+            return true;
+        }
+
+        else if(energyBefore + food > critter.energyCapacity()){
+
+            critter.setMem(4, critter.energyCapacity());
+            tiles[r][c] = new Tile(food - (critter.energyCapacity()) - energyBefore);
+            return true;
+        }
+
+        return false;
+    }
+    public boolean attack (){
+
+        int currEnergy = critter.getMemValue(4);
+        int energyUsed = critter.getMemValue(3) * Constants.ATTACK_COST;
+
+        critter.setMem(4, currEnergy - energyUsed);
+
+        if(critter.getMemValue(4) < 0){
+            world.deadCritter(critter);
+        }
+
+        Tile[][] tiles = world.getTiles();
+        int r = tiles.length - 1 - critter.getRow();
+        int c = critter.getColumn();
+
+        int direction = critter.getDirection();
+        switch(direction){
+            case 0:
+                c = c;
+                r = r + 2;
+                break;
+            case 1:
+                c = c + 1;
+                r = r + 1;
+                break;
+            case 2:
+                c = c + 1;
+                r = r - 1;
+                break;
+            case 3:
+                c = c;
+                r = r - 2;
+                break;
+            case 4:
+                c = c - 1;
+                r = r - 1;
+                break;
+            case 5:
+                c = c - 1;
+                r = r + 1;
+                break;
+        }
+
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length || tiles[tiles.length - 1 - r][c] == null || !tiles[tiles.length - 1 - r][c].getIsCritter()){
+            if(currEnergy == 0) world.deadCritter(critter);
+            return false;
+        }
+
+        Critter target = tiles[tiles.length - 1 - r][c].getCritter();
+        int size1 = critter.getMemValue(3);
+        int size2 = target.getMemValue(3);
+
+        int offensive = critter.getMemValue(2);
+        int defensive = critter.getMemValue(1);
+
+        double x = Constants.DAMAGE_INC * (size1 * offensive - size2 * defensive);
+        double Px = 1 / (1 + Math.exp(x));
+        int damageDone = (int) (Math.round( Constants.BASE_DAMAGE * size1 * Px));
+
+        int targetNewEnergy = target.getMemValue(4) - damageDone;
+        if(targetNewEnergy < 0) world.deadCritter(target);
+        else target.setMem(4, targetNewEnergy);
+
+        if(currEnergy == energyUsed){
+            world.deadCritter(critter);
+        }
+
+        return true;
+
+    }
+    public boolean grow (){
+        int cost = critter.getMemValue(3) * critter.complexity() * Constants.GROW_COST;
+        int currEnergy = critter.getMemValue(4);
+        if(currEnergy < cost){
+            world.deadCritter(critter);
+            return false;
+        }
+
+        critter.setMem(4, currEnergy - cost);
+        critter.setMem(3, critter.getMemValue(3) + 1);
+        return true;
+    }
+    public boolean bud ()
+    {
+        int newEnergy = critter.getMemValue(4) - critter.complexity() * Constants.BUD_COST;
+        if(newEnergy < 0){
+            world.deadCritter(critter);
+            return false;
+        }
+
+        critter.setMem(4, newEnergy);
+
+        Tile[][] tiles = world.getTiles();
+        int r = critter.getRow();
+        int c = critter.getColumn();
+        int direction = critter.getDirection();
+        switch(direction){
+            case 0:
+                c = c;
+                r = r + 2;
+                break;
+            case 1:
+                c = c - 1;
+                r = r + 1;
+                break;
+            case 2:
+                c = c - 1;
+                r = r - 1;
+                break;
+            case 3:
+                c = c;
+                r = r - 2;
+                break;
+            case 4:
+                c = c + 1;
+                r = r + 1;
+                break;
+            case 5:
+                c = c + 1;
+                r = r - 1;
+                break;
+        }
+
+        if( c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && ( tiles[r][c] != null
+                && tiles[r][c].getIsRock() || tiles[r][c].getIsFood() || tiles[r][c].getIsCritter())){
+            if(newEnergy == 0) world.deadCritter(critter);
+            return false;
+        }
+
+        Program clonedAST = (Program) critter.getProgram().clone();
+
+        while(Math.random() < 1/4){
+            int selecter = (int) Math.random() * clonedAST.size();
+            Node mutatedNode = clonedAST.nodeAt(selecter);
+
+            int mutation = (int) (Math.random() * 6);
+
+            switch(mutation){
+                case 0:
+                    Mutation remove = MutationFactory.getRemove();
+                    remove.apply(clonedAST, mutatedNode);
+                case 1:
+                    Mutation swap = MutationFactory.getSwap();
+                    swap.apply(clonedAST, mutatedNode);
+                case 2:
+                    Mutation replace = MutationFactory.getReplace();
+                    replace.apply(clonedAST, mutatedNode);
+                case 3:
+                    Mutation transform = MutationFactory.getTransform();
+                    transform.apply(clonedAST, mutatedNode);
+                case 4:
+                    Mutation insert = MutationFactory.getInsert();
+                    insert.apply(clonedAST, mutatedNode);
+                case 5:
+                    Mutation duplicate = MutationFactory.getDuplicate();
+                    duplicate.apply(clonedAST, mutatedNode);
+            }
+        }
+
+        int[] mem = new int[critter.getMemory().length];
+        for(int i=0; i< mem.length; i++){
+            if(i==3) mem[3] = 1;
+            else if( i == 4) mem[4] = Constants.INITIAL_ENERGY;
+            else if(i == 6) mem[6] = 0;
+            else if(i >= 7) mem[i] = 0;
+            else {
+                mem[i] = critter.getMemValue(i);
+            }
+        }
+
+        world.addCritter(critter.getSpecies(), mem, clonedAST,tiles.length - 1 - r, c, critter.getDirection() );
+
+        if(newEnergy == 0) world.deadCritter(critter);
+        return true;
+
+    }
+    public boolean mate ()
+    {
+        int cost = critter.complexity() * Constants.MATE_COST;
+        int newEnergy = critter.getMemValue(4) - cost;
+        if(newEnergy < 0){
+            world.deadCritter(critter);
+            return false;
+        }
+        critter.setMem(4, newEnergy);
+
+        Tile[][] tiles = world.getTiles();
+        int r = tiles.length - 1 - critter.getRow();
+        int c = critter.getColumn();
+        int direction = critter.getDirection();
+        switch(direction){
+            case 0:
+                c = c;
+                r = r + 2;
+                break;
+            case 1:
+                c = c + 1;
+                r = r + 1;
+                break;
+            case 2:
+                c = c + 1;
+                r = r - 1;
+                break;
+            case 3:
+                c = c;
+                r = r - 2;
+                break;
+            case 4:
+                c = c - 1;
+                r = r - 1;
+                break;
+            case 5:
+                c = c - 1;
+                r = r + 1;
+                break;
+        }
+
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && ( tiles[r][c] != null
+                && tiles[r][c].getIsRock() || tiles[r][c].getIsFood() || !tiles[r][c].getIsCritter())){
+            if(newEnergy == 0) world.deadCritter(critter);
+            return false;
+        }
+
+        Critter mate = tiles[tiles.length - 1 - r][c].getCritter();
+
+        boolean behindMate = true;
+
+        int r2 = r;
+        int c2 = c;
+
+        direction = mate.getDirection();
+        switch( direction){
+            case 0:
+                c2 = c2;
+                r2 = r2 - 2;
+                break;
+            case 1:
+                c2 = c2 - 1;
+                r2 = r2 - 1;
+                break;
+            case 2:
+                c2 = c2 - 1;
+                r2 = r2 + 1;
+                break;
+            case 3:
+                c2 = c2;
+                r2 = r2 + 2;
+                break;
+            case 4:
+                c2 = c2 + 1;
+                r2 = r2 + 1;
+                break;
+            case 5:
+                c2 = c2 + 1;
+                r2 = r2 - 1;
+                break;
+        }
+
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && (tiles[tiles.length - 1 - r][c] != null &&
+                 tiles[tiles.length - 1 - r][c].getIsRock() || tiles[tiles.length - 1 - r][c].getIsFood() || tiles[tiles.length - 1 - r][c].getIsCritter())){
+            behindMate = false;
+        }
+
+        boolean behindSelf = true;
+
+        r = tiles.length - 1 - critter.getRow();
+        c = critter.getColumn();
+        switch( critter.getDirection()){
+            case 0:
+                c = c;
+                r = r - 2;
+                break;
+            case 1:
+                c = c - 1;
+                r = r - 1;
+                break;
+            case 2:
+                c = c - 1;
+                r = r + 1;
+                break;
+            case 3:
+                c = c;
+                r = r + 2;
+                break;
+            case 4:
+                c = c + 1;
+                r = r + 1;
+                break;
+            case 5:
+                c = c + 1;
+                r = r - 1;
+                break;
+        }
+
+
+
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && (tiles[tiles.length - 1 - r][c] != null
+                && tiles[tiles.length - 1 - r][c].getIsRock() || tiles[tiles.length - 1 - r][c].getIsFood() || tiles[tiles.length - 1 - r][c].getIsCritter())){
+            behindSelf = false;
+        }
+
+        if( !behindMate && !behindSelf) return false;
+
+        if(mate.isMating() == false) {
+            critter.setMating(true);
+            return false;
+        }
+        else{
+            int matedRow;
+            int matedColumn;
+            int matedDirection;
+            if(behindMate && behindSelf){
+                if(Math.random() > 0.5) behindMate = false;
+                else behindSelf = false;
+            }
+            if(!behindMate && behindSelf){
+                matedRow = r;
+                matedColumn = c;
+                matedDirection = critter.getDirection();
+            }
+            else{
+                matedRow = r2;
+                matedColumn = c2;
+                matedDirection = mate.getDirection();
+            }
+
+            String newSpeciesName;
+            if(Math.random() > 0.5) newSpeciesName = critter.getSpecies();
+            else newSpeciesName = mate.getSpecies();
+
+            int size;
+            if(Math.random() < 0.5){
+                size = critter.getMemValue(0);
+            }
+            else{
+                size = mate.getMemValue(0);
+            }
+            int[] mem = new int[size];
+            for(int i=0; i< mem.length; i++){
+                if(i==3) mem[3] = 1;
+                else if( i == 4) mem[4] = Constants.INITIAL_ENERGY;
+                else if(i == 6) mem[6] = 0;
+                else if(i >= 7) mem[i] = 0;
+                else {
+                    if(Math.random() > 0.5) mem[i] = critter.getMemValue(i);
+                    else mem[i] = mate.getMemValue(i);
+                }
+            }
+
+            world.addCritter(newSpeciesName, mem, matedCritter(critter, mate), matedRow, matedColumn, matedDirection);
+
+            critter.setMating(false);
+            mate.setMating(false);
+        }
+
+        if(critter.getMemValue(4) == 0) world.deadCritter(critter);
+
+        return true;
+
+    }
+
+    public Program matedCritter(Critter mate1, Critter mate2){
+
+        double pickGenomeSize = Math.random();
+
+        Program mate1AST = mate1.getProgram();
+        Program mate2AST = mate2.getProgram();
+
+        Program newProgram = new ProgramImpl();
+        int size;
+        if(pickGenomeSize < 0.5){
+            size = mate1AST.getChildren().size();
+        }
+        else{
+            size = mate2AST.getChildren().size();
+        }
+
+        for(int i=0; i<size; i++){
+            if(i > mate1AST.size()) newProgram.getChildren().add(mate2AST.getChildren().get(i).clone());
+            else if(i > mate2AST.size()) newProgram.getChildren().add(mate1AST.getChildren().get(i).clone());
+            else {
+                if(Math.random() > 0.5) newProgram.getChildren().add(mate1AST.getChildren().get(i).clone());
+                else newProgram.getChildren().add(mate2AST.getChildren().get(i).clone());
+            }
+        }
+
+        return newProgram;
+    }
+
+
+    public boolean serve (int value)
+    {
+        int energySpent = critter.getMemValue(3) + value;
+
+        if(energySpent > critter.getMemValue(4)) {
+            world.deadCritter(critter);
+            return false;
+        }
+
+        critter.setMem(4, critter.getMemValue(4) - energySpent);
+
+        Tile[][] tiles = world.getTiles();
+        int r = critter.getRow();
+        int c = critter.getColumn();
+        switch(critter.getDirection()){
+            case 0:
+                c = c;
+                r = r - 2;
+                break;
+            case 1:
+                c = c + 1;
+                r = r - 1;
+                break;
+            case 2:
+                c = c + 1;
+                r = r + 1;
+                break;
+            case 3:
+                c = c;
+                r = r + 2;
+                break;
+            case 4:
+                c = c - 1;
+                r = r + 1;
+                break;
+            case 5:
+                c = c - 1;
+                r = r - 1;
+                break;
+        }
+
+        if(c < 0 || r < 0 || c >= tiles[0].length || r >= tiles.length && (tiles[tiles.length - 1 - r][c] != null
+                && tiles[tiles.length - 1 - r][c].getIsRock() || tiles[tiles.length - 1 - r][c].getIsCritter())){
+            if(critter.getMemValue(4) == 0) world.deadCritter(critter);
+            return false;
+        }
+
+        if(tiles[r][c] == null) world.addFood(tiles.length - 1 - r, c, value);
+        else tiles[r][c] = new Tile(tiles[r][c].getNumFood() + value);
+
+        if(critter.getMemValue(4) == 0){
+            world.deadCritter(critter);
+        }
+
+
+        return true;
+    }
+
+
+}
diff --git a/src/main/java/model/Interpreter.java b/src/main/java/model/Interpreter.java
new file mode 100644
index 0000000..ba759f5
--- /dev/null
+++ b/src/main/java/model/Interpreter.java
@@ -0,0 +1,481 @@
+package model;
+
+import ast.*;
+import ast.Number;
+import parse.TokenType;
+
+import java.util.LinkedList;
+
+public class Interpreter
+{
+    private World world;
+    private Critter critter;
+    private int numRulesRun;
+
+    public Interpreter(World world, Critter critter)
+    {
+        this.world = world;
+        this.critter = critter;
+        this.numRulesRun = 0;
+    }
+
+    public boolean interpret()
+    {
+        while(numRulesRun < Constants.MAX_RULES_PER_TURN)
+        {
+            if (interpretProgram(critter.getProgram()) == 0){
+                //System.out.println(critter.getLastRuleString());
+                return true;
+            }
+            critter.setMem(5, critter.getMemValue(5) + 1);
+        }
+
+        CritterAction critterAction = new CritterAction(world, critter);
+        critterAction.perform(TokenType.WAIT);
+        return false;
+    }
+    public int interpretProgram(Program program)
+    {
+        Rule lastRule = null;
+        for(Node rule : program.getChildren())
+        {
+            int i = interpretRule(rule);
+            if(i == 0)
+            {
+                lastRule = (Rule) rule;
+                critter.setLastRuleString(lastRule.toString());
+                return 0;
+            }
+            else if(i == 1)
+            {
+                lastRule = (Rule) rule;
+                critter.setLastRuleString(lastRule.toString());
+            }
+            numRulesRun ++;
+        }
+
+        if(lastRule == null)
+        {
+            return -1;
+        }
+        else return 1;
+    }
+    public int interpretRule(Node node)
+    {
+        Rule rule = (Rule) node;
+        boolean updated = false;
+        if(interpretCondition(rule.getCondition()))
+        {
+            critter.setLastRuleString(node.toString());
+            for(Node child : rule.getCommand().getChildren())
+            {
+                if(child.getClass() == Update.class)
+                {
+                    interpretUpdate(child);
+                    //System.out.println(critter.getSpecies() + ": " + child.toString());
+                    updated = true;
+                }
+                else if(child.getClass() == Action.class)
+                {
+                    //System.out.println(critter.getSpecies() + ":" + child.toString());
+                    if( !interpretAction(child) ) {
+                        //System.out.println("failed action bozo");
+                    }
+                    return 0;
+                }
+            }
+        }
+        if(updated) return 1;
+        else return -1;
+    }
+    public boolean interpretUpdate(Node update)
+    {
+        Update curr = (Update) update;
+        int memType = interpretExpression(curr.getMemType().getExpr());
+        int updateValue = interpretExpression(curr.getExpr());
+
+        if(memType < 6 || memType >= critter.getMemValue(0))
+        {
+            System.out.println("not valid mem value bozo");
+            return false;
+        }
+        critter.setMem(memType, updateValue);
+
+
+        return true;
+    }
+    public boolean interpretAction(Node node)
+    {
+        Action action = (Action) node;
+        TokenType tt = action.getName();
+        CritterAction critterAction = new CritterAction(world, critter);
+
+        if(tt == TokenType.SERVE){
+            return critterAction.serve(interpretExpression(action.getExpr()));
+        }
+        else{
+            return critterAction.perform(tt);
+        }
+    }
+    public boolean interpretCondition(Node condition){
+
+        if(condition.getClass() == Relation.class){
+            return interpretRelation(condition);
+        }
+
+        BinaryCondition bc = (BinaryCondition) condition;
+        boolean left = false;
+        boolean right = false;
+        BinaryCondition.Operator op = bc.getOp();
+        if(bc.getLeft().getClass() == BinaryCondition.class){
+            left = interpretCondition(bc.getLeft());
+        }
+        else if(bc.getLeft().getClass() == Relation.class){
+            left = interpretRelation(bc.getLeft());
+        }
+        if(bc.getRight().getClass() == BinaryCondition.class){
+            right = interpretCondition(bc.getRight());
+        }
+        else if(bc.getRight().getClass() == Relation.class){
+            right = interpretRelation(bc.getRight());
+        }
+
+        if(op == BinaryCondition.Operator.AND){
+            return left && right;
+        }
+        else return left || right;
+
+
+    }
+
+    public boolean interpretRelation(Node node){
+        Relation relation = (Relation) node;
+        int left = interpretExpression(relation.getLeft());
+        int right = interpretExpression(relation.getRight());
+        String rel = relation.getOperator().toString();
+
+        switch(rel){
+            case("<"):
+                return (left < right);
+            case("<="):
+                return (left <= right);
+            case("="):
+                return (left == right);
+            case(">="):
+                return (left >= right);
+            case(">"):
+                return (left > right);
+            case("!="):
+                return (left != right);
+            default:
+                System.out.println(rel + " is not a valid relation operator");
+                return false;
+        }
+    }
+
+    public int interpretExpression(Node node){
+        Expr expr = (Expr) node;
+        if(expr.getClass() == BinaryOp.class){
+            BinaryOp binOp = (BinaryOp) expr;
+            int left = interpretExpression((binOp.getLeft()));
+            int right = interpretExpression(binOp.getRight());
+            String op = binOp.getOp().toString();
+
+            switch(op){
+                case("+"):
+                    return left + right;
+                case("-"):
+                    return left - right;
+                case("*"):
+                    return left * right;
+                case("/"):
+                    return (left / right);
+                case("mod"):
+                    return (left % right);
+                default:
+                    System.out.println(op + " is not a valid binary operator stoopid");
+                    return -1;
+
+            }
+        }
+
+        else if(expr.getClass() == NegativeExpr.class){
+            NegativeExpr negged = (NegativeExpr) expr;
+            return -1 * interpretExpression(negged.getRight());
+        }
+
+        else if(expr.getClass() == Number.class){
+            Number num = (Number) expr;
+            return num.getNum();
+        }
+
+        else if(expr.getClass() == Mem.class){
+            Mem mem = (Mem) expr;
+            return critter.getMemValue(interpretExpression(mem.getExpr()));
+        }
+
+        else if(expr.getClass() == NearbySensor.class)
+        {
+            NearbySensor ns = (NearbySensor) expr;
+            return interpretNearbySensor(interpretExpression(ns.getExpr()));
+        }
+
+        else if(expr.getClass() == AheadSensor.class)
+        {
+            AheadSensor as = (AheadSensor) expr;
+            return interpretAheadSensor(interpretExpression(as.getExpr()));
+        }
+
+        else if(expr.getClass() == SmellSensor.class)
+        {
+            return interpretSmellSensor();
+        }
+
+        else if(expr.getClass() == RandomSensor.class)
+        {
+            RandomSensor rs = (RandomSensor) expr;
+            return interpretExpression(rs.getExpr());
+        }
+
+        return 0;
+    }
+
+    public int interpretNearbySensor(int dir)
+    {
+        Tile[][] tiles = world.getTiles();
+        dir = dir + critter.getDirection() % 6;
+        int row = critter.getRow();
+        int column = critter.getColumn();
+        int info;
+        if (dir == 0)
+        {
+            row -= 2;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 1)
+        {
+            row--;
+            column++;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 2)
+        {
+            row++;
+            column++;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 3)
+        {
+            row += 2;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 4)
+        {
+            row++;
+            column--;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else
+        {
+            row--;
+            column--;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+
+        if (info <= 0)
+        {
+            return info;
+        }
+        else
+        {
+            Critter target = tiles[row][column].getCritter();
+            return target.getMemValue(3) * 1000 + target.getMemValue(6) * 10 + target.getDirection();
+        }
+    }
+
+    public int interpretAheadSensor(int dist)
+    {
+        Tile[][] tiles = world.getTiles();
+        dist = Math.max(dist, 0);
+        int dir = critter.getDirection();
+        int row = critter.getRow();
+        int column = critter.getColumn();
+        int info;
+        if (dir == 0)
+        {
+            row -= dist * 2;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 1)
+        {
+            row -= dist;
+            column += dist;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 2)
+        {
+            row += dist;
+            column += dist;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 3)
+        {
+            row += dist * 2;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else if (dir == 4)
+        {
+            row += dist;
+            column -= dist;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+        else
+        {
+            row -= dist;
+            column -= dist;
+            info = world.getTerrainInfo(column, tiles.length - 1 - row);
+        }
+
+        if (info <= 0)
+        {
+            return info;
+        }
+        else
+        {
+            Critter target = tiles[row][column].getCritter();
+            return target.getMemValue(3) * 1000 + target.getMemValue(6) * 10 + target.getDirection();
+        }
+    }
+
+    public int interpretSmellSensor()
+    {
+        Tile[][] tiles = world.getTiles();
+        int row = critter.getRow();
+        int column = critter.getColumn();
+        int dir = critter.getDirection();
+        LinkedList<int[]> tileSearch = new LinkedList<int[]>();
+        if (row - 2 > 0) tileSearch.add(new int[]{row - 2, column});
+        if (row - 1 > 0 && column + 1 < tiles[0].length) tileSearch.add(new int[]{row - 1, column + 1});
+        if (row + 1 < tiles.length && column + 1 < tiles[0].length) tileSearch.add(new int[]{row + 1, column + 1});
+        if (row + 2 < tiles.length) tileSearch.add(new int[]{row + 2, column});
+        if (row + 1 < tiles.length && column - 1 > 0)tileSearch.add(new int[]{row + 1, column - 1});
+        if (row - 1 > 0 && column - 1 > 0) tileSearch.add(new int[]{row - 1, column - 1});
+        int[] foodCoordinates = findNearestFood(tiles, tileSearch);
+        int cx = column;
+        int cy = tiles.length - 1 - row;
+        int fx = foodCoordinates[1];
+        int fy = tiles.length - 1 - foodCoordinates[0];
+
+
+
+        int dist = Math.max(Math.abs(fx - cx), Math.abs(fx - cx + fy - cy) / 2);
+        dist = Math.max(dist, Math.abs(fx - cx - fy + cy) / 2);
+        if (foodCoordinates[0] == -1 || dist > Constants.MAX_SMELL_DISTANCE)
+        {
+            return 1000000;
+        }
+
+        // based off assumption row is first
+
+        int deltax = fx - cx;
+        int deltay = fy - cy;
+
+        double tanned;
+        double angle;
+        if(deltax == 0 )
+        {
+            angle = 90;
+        }
+        else {
+            tanned = deltay/deltax;
+            angle = Math.atan(tanned);
+        }
+
+        if( (deltay) < 0)
+        {
+            angle += 180;
+        }
+
+        int dirOfFood = critter.getDirection();
+        if(angle >= 0 && angle < 60)
+        {
+            dirOfFood = 1 - dirOfFood + 6;
+        }
+        else if(angle >= 60 && angle < 120)
+        {
+            dirOfFood = 0 - dirOfFood + 6;
+        }
+        else if(angle >= 120 && angle < 180)
+        {
+            dirOfFood = 5 - dirOfFood + 6;
+        }
+        else if(angle >= 180 && angle < 240)
+        {
+            dirOfFood = 4 - dirOfFood + 6;
+        }
+        else if(angle >= 240 && angle < 300)
+        {
+            dirOfFood = 3 - dirOfFood + 6;
+        }
+        else if(angle >= 300 && angle < 360)
+        {
+            dirOfFood = 2 - dirOfFood + 6;
+        }
+        dirOfFood %= 6;
+        System.out.println("direction: " + dirOfFood);
+        System.out.println("return: " + 1000 * dist + dirOfFood);
+        return 1000 * dist + dirOfFood;
+    }
+
+    public int[] findNearestFood(Tile[][] tiles, LinkedList<int[]> tileSearch)
+    {
+        while (tileSearch.peek() != null)
+        {
+            int[] coordinates = tileSearch.poll();
+            if (tiles[coordinates[0]][coordinates[1]] != null && tiles[coordinates[0]][coordinates[1]].getIsFood())
+            {
+                return coordinates;
+            }
+            int rowSize = tiles.length;
+            int columnSize = tiles[0].length;
+            int row = coordinates[0];
+            int column = coordinates[1];
+            if (row - 2 >= 0)
+            {
+                tileSearch.add(new int[]{row - 2, column});
+            }
+            if (row - 1 >= 0 && column + 1 < columnSize)
+            {
+                tileSearch.add(new int[]{row - 1, column + 1});
+            }
+            if (row + 1 < rowSize && column + 1 < columnSize)
+            {
+                tileSearch.add(new int[]{row + 1, column + 1});
+            }
+            if (row + 1 < rowSize)
+            {
+                tileSearch.add(new int[]{row + 2, column});
+            }
+            if (row + 1 < rowSize && column - 1 >= 0)
+            {
+                tileSearch.add(new int[]{row + 1, column - 1});
+            }
+            if (row - 1 >= 0 && column - 1 >= 0)
+            {
+                tileSearch.add(new int[]{row - 1, column - 1});
+            }
+        }
+        return new int[]{-1, -1};
+    }
+
+    public int interpretRandomSensor(RandomSensor rs, int n)
+    {
+        return n < 2 ? 0 : (int) (Math.random() * n);
+    }
+
+
+    public void setMem(int memIndex, int changeNumber)
+    {
+        critter.setMem(memIndex, changeNumber);
+    }
+}
diff --git a/src/main/java/model/ReadOnlyCritter.java b/src/main/java/model/ReadOnlyCritter.java
new file mode 100644
index 0000000..a291032
--- /dev/null
+++ b/src/main/java/model/ReadOnlyCritter.java
@@ -0,0 +1,24 @@
+package model;
+
+import cms.util.maybe.Maybe;
+
+public interface ReadOnlyCritter {
+    /** @return critter species. */
+    String getSpecies();
+
+    /**
+     * Hint: you should consider making a defensive copy of the array.
+     *
+     * @return an array representation of critter's memory.
+     */
+    int[] getMemory();
+
+    /** @return current program string of the critter. */
+    String getProgramString();
+
+    /**
+     * @return last rule executed by the critter on its previous turn, or {@code Maybe.none()} if it has not
+     *     executed any.
+     */
+    Maybe<String> getLastRuleString();
+}
diff --git a/src/main/java/model/ReadOnlyWorld.java b/src/main/java/model/ReadOnlyWorld.java
new file mode 100644
index 0000000..4588f5e
--- /dev/null
+++ b/src/main/java/model/ReadOnlyWorld.java
@@ -0,0 +1,27 @@
+package model;
+
+import cms.util.maybe.Maybe;
+
+public interface ReadOnlyWorld
+{
+    /** @return number of steps */
+    int getSteps();
+
+    /** @return number of alive critters. */
+    int getNumberOfAliveCritters();
+
+    /**
+     * @param c column id.
+     * @param r row id.
+     * @return the critter at the specified hex.
+     */
+    Maybe<ReadOnlyCritter> getReadOnlyCritter(int c, int r);
+
+    /**
+     * @param c column id.
+     * @param r row id.
+     * @return 0 if the cell is empty. -1 if it is rock, -(X+1) if it is X food, X+1 if it contains a critter facing 
+     *         in direction X. Treat out-of-bound or invalid hex as rock.
+     */
+    int getTerrainInfo(int c, int r);
+}
diff --git a/src/main/java/model/Tile.java b/src/main/java/model/Tile.java
new file mode 100644
index 0000000..8c584e4
--- /dev/null
+++ b/src/main/java/model/Tile.java
@@ -0,0 +1,68 @@
+package model;
+
+public class Tile {
+
+    private boolean isRock;
+    private boolean isFood;
+    private boolean isCritter;
+
+    private int numFood = 0;
+    private Critter critter;
+
+    Tile()
+    {
+        isRock = true;
+        this.isFood = false;
+        this.isCritter = false;
+    }
+
+    Tile(int numFood)
+    {
+        this.isFood = true;
+        this.isRock = false;
+        this.isCritter = false;
+        this.numFood = numFood;
+    }
+
+    Tile(Critter critter)
+    {
+        this.isCritter = true;
+        this.isFood = false;
+        this.isRock = false;
+        this.critter = critter;
+    }
+
+    Tile(Boolean bool)
+    {
+        this.isCritter = false;
+        this.isFood = false;
+        this.isRock = false;
+    }
+
+    public boolean getIsRock()
+    {
+        return isRock;
+    }
+
+    public boolean getIsFood()
+    {
+        return numFood > 0 ? true : false;
+    }
+
+    public boolean getIsCritter()
+    {
+        return isCritter;
+    }
+
+    public int getNumFood()
+    {
+        return numFood;
+    }
+
+    public Critter getCritter()
+    {
+        return critter;
+    }
+
+
+}
diff --git a/src/main/java/model/World.java b/src/main/java/model/World.java
new file mode 100644
index 0000000..dc6478c
--- /dev/null
+++ b/src/main/java/model/World.java
@@ -0,0 +1,331 @@
+package model;
+
+import ast.Mutation;
+import ast.MutationFactory;
+import ast.Node;
+import ast.Program;
+import cms.util.maybe.Maybe;
+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;
+
+import java.io.PrintStream;
+import java.util.ArrayList;
+
+public class World extends ControlOnlyWorld implements ReadOnlyWorld
+{
+    private int numRows;
+    private int numColumns;
+    private Tile[][] tiles;
+    private int numSteps;
+    private ArrayList<Critter> critters;
+    private boolean enableManna;
+    private boolean enableForcedMutation;
+
+    public World()
+    {
+        this.numRows = Constants.HEIGHT;
+        this.numColumns = Constants.WIDTH;
+        this.tiles = new Tile[numRows][numColumns];
+        this.critters = new ArrayList<>();
+    }
+
+    public World(int width, int height, boolean enableManna, boolean enableForcedMutation)
+    {
+        this.numRows = height;
+        this.numColumns = width;
+        this.tiles = new Tile[numRows][numColumns];
+        this.critters = new ArrayList<>();
+        this.enableManna = enableManna;
+        this.enableForcedMutation = enableForcedMutation;
+    }
+
+    public Tile[][] getTiles()
+    {
+        return tiles;
+    }
+
+//    public int getNumRows()
+//    {
+//        return numRows;
+//    }
+//
+//    public int getNumColumns()
+//    {
+//        return numColumns;
+//    }
+
+    @Override
+    public boolean addCritter(String species, int[] mem, Program ast)
+    {
+//        System.out.println(numRows + " " + numColumns);
+        boolean flag = false;
+        int count = 0;
+        while (!flag && count < numRows * numColumns)
+        {
+            int row = (int)(Math.random() * numRows);
+            int column = (tiles.length - 1 - row) % 2 == 0 ? (int) (Math.random() * ((numColumns + 1) / 2)) * 2:
+                    (int) (Math.random() * (numColumns / 2)) * 2 + 1;
+//            if ((tiles.length - 1 - row) % 2 == 0)
+//            {
+//                System.out.println("even");
+//            }
+//            else
+//            {
+//                System.out.println("odd");
+//            }
+//            System.out.println((tiles.length - 1 - row) + " " + column);
+//            System.out.println();
+            flag = addCritter(species, mem, ast, row, column, (int) (Math.random() * 6));
+            count++;
+        }
+        return flag;
+    }
+
+    @Override
+    public boolean addCritter(String species, int[] mem, Program ast, int row, int column, int dir)
+    {
+        row = tiles.length - 1 - row;
+        if(tiles[row][column] != null)
+        {
+            Tile curr = tiles[row][column];
+            if(curr.getIsCritter() || curr.getIsFood() || curr.getIsRock()) return false;
+        }
+        tiles[row][column] = new Tile(new Critter(species, ast, mem, row, column, dir));
+        critters.add(tiles[row][column].getCritter());
+        return true;
+    }
+
+
+    @Override
+    public boolean addRock(int row, int column)
+    {
+        row = tiles.length - 1 - row;
+        if(tiles[row][column] != null)
+        {
+            Tile curr = tiles[row][column];
+            if(curr.getIsCritter() || curr.getIsFood() || curr.getIsRock()) return false;
+        }
+        tiles[row][column] = new Tile();
+        return true;
+    }
+
+    @Override
+    public boolean addFood(int row, int column, int amount)
+    {
+        row = tiles.length - 1 - row;
+        if(tiles[row][column] != null)
+        {
+            Tile curr = tiles[row][column];
+            if(curr.getIsCritter() || curr.getIsFood() || curr.getIsRock()) return false;
+        }
+        tiles[row][column] = new Tile(amount);
+        return true;
+    }
+
+    @Override
+    public void advanceTimeStep()
+    {
+        if(critters.size() == 0) System.out.println("all critters dead at timestep: " + numSteps);
+
+        for (int i = 0; i < critters.size(); i++)
+        {
+            Critter critter = critters.get(i);
+            if(critter.isJustCreated())
+            {
+                critter.setJustcreated(false);
+                continue;
+            }
+//            System.out.println(critter.getColumn() + " " + (tiles.length - 1 - critter.getRow()));
+//            System.out.println(critter.getLastRuleString());
+//            System.out.println();
+
+            Interpreter interpreter = new Interpreter(this, critter);
+            interpreter.interpretProgram(critter.getProgram());
+            if (!critters.contains(critter))
+            {
+                i--;
+            }
+        }
+        for(Critter critter: critters)
+        {
+            if(critter.isMating()){
+                critter.setMem(4, critter.getMemValue(4) + critter.complexity() * Constants.MATE_COST - critter.getMemValue(3));
+            }
+            critter.setMating(false);
+        }
+
+//        for(Critter critter : critters){
+//            System.out.println(critter.toString());
+//
+//        }
+        numSteps++;
+    }
+
+    @Override
+    public void printWorld(PrintStream out)
+    {
+        for (int i = 0; i < tiles.length; i++)
+        {
+            for (int j = (tiles.length - 1 - i) % 2; j < tiles[i].length; j += 2)
+            {
+                if (j == 1)
+                {
+                    System.out.print(" ");
+                }
+
+                if (tiles[i][j] == null)
+                {
+                    System.out.print("-");
+                }
+                else if (tiles[i][j].getIsRock())
+                {
+                    System.out.print("#");
+                }
+                else if (tiles[i][j].getIsCritter())
+                {
+                    System.out.print(tiles[i][j].getCritter().getDirection());
+                }
+                else if (tiles[i][j].getIsFood())
+                {
+                    System.out.print("F");
+                }
+
+                if (j < tiles[i].length - 1)
+                {
+                    System.out.print(" ");
+                }
+            }
+            System.out.println();
+        }
+    }
+
+    @Override
+    public int getSteps()
+    {
+        return numSteps;
+    }
+
+    @Override
+    public int getNumberOfAliveCritters()
+    {
+        return critters.size();
+    }
+
+    @Override
+    public Maybe<ReadOnlyCritter> getReadOnlyCritter(int c, int r)
+    {
+        if(c >= numColumns || c < 0 || r >= numRows || r < 0 || tiles[r][c] == null || !tiles[r][c].getIsCritter()) return Maybe.none();
+
+        return Maybe.some(tiles[r][c].getCritter());
+    }
+
+    @Override
+    public int getTerrainInfo(int c, int r)
+    {
+        r = tiles.length - 1 - r;
+        if(c >= numColumns || c < 0 || r >= numRows || r < 0) return Constants.ROCK_VALUE; // out of bounds indices should be treated as a rock
+        if(tiles[r][c] == null) return 0;
+        if(tiles[r][c].getIsRock()) return Constants.ROCK_VALUE; // -1
+        else if(tiles[r][c].getIsFood()) return (tiles[r][c].getNumFood() + 1) * -1;
+        else if(tiles[r][c].getIsCritter()) return tiles[r][c].getCritter().getDirection() + 1;
+        return 0;
+    }
+
+    public boolean deadCritter(Critter critter)
+    {
+        int row = critter.getRow();
+        int column = critter.getColumn();
+        if( !tiles[row][column].getCritter().equals(critter) ) return false;
+
+        System.out.println(critter.getSpecies() + " died at time step: " + numSteps);
+        tiles[row][column] = new Tile(critter.getMemValue(3) * Constants.FOOD_PER_SIZE);
+        critters.remove(critter);
+
+        return true;
+    }
+
+    public void setCritterPosition(Critter critter, int r, int c)
+    {
+        tiles[critter.getRow()][critter.getColumn()] = null;
+        tiles[r][c] = new Tile(critter);
+        critter.setPosition(r, c);
+    }
+
+    @Override
+    public void addManna()
+    {
+        if(critters.size() == 0){
+            return;
+        }
+
+        if(Math.random() > ((double) (1) / (double) (getNumberOfAliveCritters()))) return;
+
+        int numTiles = numRows * numColumns;
+
+        for(int i=0; i < ( Constants.MANNA_COUNT * numTiles / 1000); i++){
+
+            int r = (int)(Math.random() * numRows);
+            int c = (tiles.length - 1 - r) % 2 == 0 ? (int) (Math.random() * ((numColumns + 1) / 2)) * 2:
+                    (int) (Math.random() * (numColumns / 2)) * 2 + 1;
+
+            if (tiles[r][c] == null)
+            {
+                tiles[r][c] = new Tile(Constants.MANNA_AMOUNT);
+            }
+
+            else
+            {
+                while (tiles[r][c].getIsRock() || tiles[r][c].getIsCritter())
+                {
+                    r = (int) (Math.random() * numRows);
+                    c = (tiles.length - 1 - r) % 2 == 0 ? (int) (Math.random() * ((numColumns + 1) / 2)) * 2 :
+                            (int) (Math.random() * (numColumns / 2)) * 2 + 1;
+                    if (tiles[r][c] == null)
+                    {
+                        tiles[r][c] = new Tile(Constants.MANNA_AMOUNT);
+                        break;
+                    }
+                }
+                if (tiles[r][c] != null)
+                {
+                    tiles[r][c] = new Tile(tiles[r][c].getNumFood() + Constants.MANNA_AMOUNT);
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public void forcedMutate()
+    {
+        for(Critter critter : critters)
+        {
+            Program ast = critter.getProgram();
+            int selector = (int) Math.random() * ast.size();
+            Node mutatedNode = ast.nodeAt(selector);
+
+            int mutation = (int) (Math.random() * 6);
+
+            switch(mutation){
+                case 0:
+                    Mutation remove = MutationFactory.getRemove();
+                    remove.apply(ast, mutatedNode);
+                case 1:
+                    Mutation swap = MutationFactory.getSwap();
+                    swap.apply(ast, mutatedNode);
+                case 2:
+                    Mutation replace = MutationFactory.getReplace();
+                    replace.apply(ast, mutatedNode);
+                case 3:
+                    Mutation transform = MutationFactory.getTransform();
+                    transform.apply(ast, mutatedNode);
+                case 4:
+                    Mutation insert = MutationFactory.getInsert();
+                    insert.apply(ast, mutatedNode);
+                case 5:
+                    Mutation duplicate = MutationFactory.getDuplicate();
+                    duplicate.apply(ast, mutatedNode);
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
index 53e4276..bbdf120 100644
--- a/src/main/java/parse/ParserImpl.java
+++ b/src/main/java/parse/ParserImpl.java
@@ -8,7 +8,6 @@ import java.io.Reader;
 
 class ParserImpl implements Parser
 {
-
     @Override
     public Program parse(Reader r) throws SyntaxError
     {
@@ -36,7 +35,7 @@ class ParserImpl implements Parser
         }
         if (ret.getChildren().size() < 1)
         {
-            throw new UnsupportedOperationException();
+            throw new SyntaxError(t.lineNumber(), "invalid input program");
         }
         return ret;
     }
@@ -77,7 +76,7 @@ class ParserImpl implements Parser
         }
         if (command.getChildren().size() < 1)
         {
-            throw new UnsupportedOperationException();
+            throw new SyntaxError(t.lineNumber(), "invalid input program");
         }
         return command;
     }
@@ -110,13 +109,13 @@ class ParserImpl implements Parser
     public static Action parseAction(Tokenizer t) throws SyntaxError
     {
 //        System.out.println("parseAction");
-        if(t.peek().getType().category() != TokenCategory.ACTION) throw new UnsupportedOperationException();
+        if(t.peek().getType().category() != TokenCategory.ACTION) throw new SyntaxError(t.lineNumber(), "invalid input program");
         TokenType actionName = t.next().getType();
         if(actionName == TokenType.SERVE)
         {
-            consume(t, TokenType.LBRACE);
+            consume(t, TokenType.LBRACKET);
             Expr deezN = parseExpression(t);
-            consume(t, TokenType.RBRACE);
+            consume(t, TokenType.RBRACKET);
             Action ret = new Action(actionName, deezN);
             deezN.setParent(ret);
             return ret;
@@ -169,7 +168,7 @@ class ParserImpl implements Parser
         else
         {
             Expr left = parseExpression(t);
-            if(t.peek().getType().category() != TokenCategory.RELOP) throw new UnsupportedOperationException( );
+            if(t.peek().getType().category() != TokenCategory.RELOP) throw new SyntaxError(t.lineNumber(), "invalid input program");
             TokenType rel = t.next().getType();
             Expr right = parseExpression(t);
             Condition ret = new Relation(left, rel, right);
@@ -243,7 +242,7 @@ class ParserImpl implements Parser
         else if (t.peek().getType() == TokenType.MINUS)
         {
             t.next();
-            return new NegativeExpr(new Negative(), parseFactor(t));
+            return new NegativeExpr(parseFactor(t));
         }
         else if (t.peek().isSensor())
         {
@@ -251,7 +250,7 @@ class ParserImpl implements Parser
         }
         else
         {
-            throw new UnsupportedOperationException();
+            throw new SyntaxError(t.lineNumber(), "invalid input program");
         }
     }
 
@@ -295,7 +294,7 @@ class ParserImpl implements Parser
         }
         else
         {
-            throw new UnsupportedOperationException();
+            throw new SyntaxError(t.lineNumber(), "invalid input program");
         }
     }
 
@@ -309,7 +308,7 @@ class ParserImpl implements Parser
         Token temp = t.next();
         if(temp.getType() != tt)
         {
-            throw new UnsupportedOperationException();
+            throw new SyntaxError(t.lineNumber(), "invalid input program");
         }
     }
 }
diff --git a/src/main/java/parse/TokenType.java b/src/main/java/parse/TokenType.java
index b2c6ffd..d652443 100644
--- a/src/main/java/parse/TokenType.java
+++ b/src/main/java/parse/TokenType.java
@@ -6,7 +6,8 @@ import java.util.Map;
 
 /** An instance represents a Token with a category and a string representation.
  */
-public enum TokenType {
+public enum TokenType
+{
     MEM(TokenCategory.OTHER, "mem"),
     WAIT(TokenCategory.ACTION, "wait"),
     FORWARD(TokenCategory.ACTION, "forward"),
@@ -60,7 +61,8 @@ public enum TokenType {
     private static final Map<String, TokenType> stringToTypeMap;
 
     // static initializer to initialize the values of stringToTypeMap
-    static {
+    static
+    {
         final Map<String, TokenType> temp = new HashMap<>();
         for (TokenType t : TokenType.values()) {
             temp.put(t.stringRep, t);
diff --git a/src/main/java/parse/Tokenizer.java b/src/main/java/parse/Tokenizer.java
index 4f0b221..470de93 100644
--- a/src/main/java/parse/Tokenizer.java
+++ b/src/main/java/parse/Tokenizer.java
@@ -8,6 +8,7 @@ import java.util.Queue;
 
 import easyIO.EOF;
 import easyIO.Scanner;
+import easyIO.UnexpectedInput;
 
 /**
  * A Tokenizer turns a Reader into a stream of tokens that can be iterated over
@@ -79,11 +80,16 @@ public class Tokenizer implements Iterator<Token> {
      * @throws TokenizerIOException if an IOException was thrown while trying
      *                              to read from the source Reader
      */
-    public Token peek() {
-        if (tokens.isEmpty()) {
-            try {
+    public Token peek()
+    {
+        if (tokens.isEmpty())
+        {
+            try
+            {
                 lexOneToken();
-            } catch (IOException e) {
+            }
+            catch (IOException e)
+            {
                 throw new TokenizerIOException(e);
             }
         }
@@ -151,7 +157,15 @@ public class Tokenizer implements Iterator<Token> {
                     addToken(TokenType.MUL);
                     break;
                 case '/':
-                    addToken(TokenType.DIV);
+                    if (in.peek() == '/')
+                    {
+                        in.nextLine();
+                        lexOneToken();
+                    }
+                    else
+                    {
+                        addToken(TokenType.DIV);
+                    }
                     break;
                 case '<':
                     lexLAngle();
@@ -174,7 +188,9 @@ public class Tokenizer implements Iterator<Token> {
                     else addErrorToken(
                         String.format("Unrecognized character %c", c));
             }
-        } catch (EOF eof) {
+        }
+        catch (EOF | UnexpectedInput eof)
+        {
             addEOFToken();
         }
     }
diff --git a/src/test/java/controller/BigTest.java b/src/test/java/controller/BigTest.java
new file mode 100644
index 0000000..2a673b1
--- /dev/null
+++ b/src/test/java/controller/BigTest.java
@@ -0,0 +1,18 @@
+package controller;
+
+import org.junit.jupiter.api.Test;
+
+public class BigTest
+{
+    @Test
+    public void testBig()
+    {
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.loadWorld("src\\test\\resources\\A5files\\big_world.txt", true, false);
+        controller.printWorld(System.out);
+        System.out.println();
+        controller.advanceTime(100);
+        System.out.println();
+        controller.printWorld(System.out);
+    }
+}
diff --git a/src/test/java/controller/ConsoleControllerTest.java b/src/test/java/controller/ConsoleControllerTest.java
new file mode 100644
index 0000000..767b084
--- /dev/null
+++ b/src/test/java/controller/ConsoleControllerTest.java
@@ -0,0 +1,177 @@
+package controller;
+
+import controller.DeterministicHexInformation.CritterHex;
+import model.ReadOnlyWorld;
+import org.junit.jupiter.api.Test;
+
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+import static controller.DeterministicHexInformation.NonCritterHex.EMPTY_HEX;
+import static controller.DeterministicHexInformation.NonCritterHex.ROCK_HEX;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public final class ConsoleControllerTest {
+    private static final String COMMON_TEST_PATH = Paths.get("src", "test", "resources", "A5files").toString();
+
+    @Test
+    public void testRandomWorld()
+    {
+        // Test a randomly generated world only contains empty and rock.
+        final var controller = ControllerFactory.getConsoleController();
+        controller.newWorld();
+        final var world = controller.getReadOnlyWorld();
+        for (int i = -1; i < 100; i++) {
+            for (int j = -1; j < 100; j++) {
+                if ((i + j) % 2 != 0) continue;
+
+                final var hexValue = world.getTerrainInfo(i, j);
+                if (i == -1 || j == -1) {
+                    assertEquals(-1, hexValue, "Out of bound tiles must have rock's hex values");
+                }
+                assertTrue(hexValue == 0 || hexValue == -1,
+                        "A randomly initialized world should only contain empty and rock tiles!");
+            }
+        }
+    }
+
+    @Test
+    public void emptyWorldTest() {
+        // An empty 10x10 empty world.
+        // This test mostly tests that the student's solution return -1 for hex outside of the world.
+        runTest(
+                Paths.get(COMMON_TEST_PATH, "empty.wld").toString(),
+                // Step 0
+                new StepState(0, new ExpectedHex(3, 3, EMPTY_HEX))
+        );
+    }
+
+    @Test
+    public void smallWorldTest() {
+        // A simple 1x1 empty world.
+        // This test mostly tests that the student's solution return -1 for hex outside of the world.
+        runTest(
+                Paths.get(COMMON_TEST_PATH, "small_world.txt").toString(),
+                // Step 0: the state of the world after load
+                new StepState(
+                        0,
+                        new ExpectedHex(0, 0, EMPTY_HEX),
+                        new ExpectedHex(1, 1, ROCK_HEX)),
+                // Step 1: the state of the world after one step
+                new StepState(
+                        0,
+                        new ExpectedHex(0, 0, EMPTY_HEX),
+                        new ExpectedHex(1, 1, ROCK_HEX),
+                        new ExpectedHex(-1, 31, ROCK_HEX),
+                        new ExpectedHex(-1, -1, ROCK_HEX))
+        );
+    }
+
+    @Test
+    public void spaceWorldTest() {
+        // A simple 1x1 world where the critter does nothing.
+        runTest(
+                Paths.get(COMMON_TEST_PATH, "space_world.txt").toString(),
+                // Step 0
+                new StepState(
+                        1,
+                        new ExpectedHex(0, 0, CritterHex.builderWithEnergy(500).build())
+                ),
+                // Step 1
+                new StepState(
+                        1,
+                        new ExpectedHex(0, 0, CritterHex.builderWithEnergy(500).build())
+                )
+        );
+    }
+
+    private void runTest(String worldFile, StepState initialState, StepState... steps) {
+        final var controller = ControllerFactory.getConsoleController();
+        assertTrue(controller.loadWorld(worldFile, false, false), String.format("World file %s failed to load.", worldFile));
+        checkState(controller.getReadOnlyWorld(), 0, initialState);
+        int stepId = 0;
+        while (stepId < steps.length) {
+            final var stepState = steps[stepId];
+            controller.advanceTime(1);
+            stepId++;
+            checkState(controller.getReadOnlyWorld(), stepId, stepState);
+        }
+    }
+
+    private static void checkState(ReadOnlyWorld world, int stepId, StepState stepState) {
+        assertEquals(stepId, world.getSteps(), "Step counter disagrees in step " + stepId);
+        assertEquals(stepState.population, world.getNumberOfAliveCritters(), "Critter population disagrees in step " + stepId);
+        for (final var expectedHex : stepState.expectedHexList) {
+            final var actualHexInformation =
+                    DeterministicHexInformation.fromWorldLocation(world, expectedHex.column, expectedHex.row);
+            assertEquals(
+                    expectedHex.information,
+                    actualHexInformation,
+                    "Hex information disagrees at (" + expectedHex.column + ", " + expectedHex.row + ") in step " + stepId);
+        }
+    }
+
+    private static final class StepState {
+        public final int population;
+        public final List<ExpectedHex> expectedHexList;
+
+        public StepState(int population, ExpectedHex... expectedHexList) {
+            this.population = population;
+            this.expectedHexList = Arrays.asList(expectedHexList);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            StepState stepState = (StepState) o;
+            return population == stepState.population &&
+                    expectedHexList.equals(stepState.expectedHexList);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(population, expectedHexList);
+        }
+
+        @Override
+        public String toString() {
+            return String.format("StepState{population=%d, expectedHexList=%s}", population, expectedHexList);
+        }
+    }
+
+    private static final class ExpectedHex {
+        public final int column;
+        public final int row;
+        public final DeterministicHexInformation information;
+
+        public ExpectedHex(int column, int row, DeterministicHexInformation information) {
+            this.column = column;
+            this.row = row;
+            this.information = information;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            ExpectedHex that = (ExpectedHex) o;
+            return column == that.column &&
+                    row == that.row &&
+                    information.equals(that.information);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(column, row, information);
+        }
+
+        @Override
+        public String toString() {
+            return String.format("ExpectedHex{column=%d, row=%d, information=%s}", column, row, information);
+        }
+    }
+}
diff --git a/src/test/java/controller/ControllerTest.java b/src/test/java/controller/ControllerTest.java
new file mode 100644
index 0000000..35becec
--- /dev/null
+++ b/src/test/java/controller/ControllerTest.java
@@ -0,0 +1,83 @@
+package controller;
+
+import controller.Controller;
+import controller.ControllerFactory;
+import org.junit.jupiter.api.Test;
+
+public class ControllerTest
+{
+    @Test
+    public void testLoadWorld()
+    {
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.loadWorld("src\\test\\resources\\A5files\\test_world.txt", true, false);
+        controller.printWorld(System.out);
+    }
+
+    @Test
+    public void testNewWorld()
+    {
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.newWorld();
+        controller.loadCritters("src\\test\\resources\\A5files\\test_critter.txt", 10);
+        controller.printWorld(System.out);
+    }
+
+    @Test
+    public void testAdvanceTimeStep()
+    {
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.loadWorld("src\\test\\resources\\A5files\\test_world.txt", true, false);
+//        controller.printWorld(System.out);
+//        System.out.println();
+        controller.advanceTime(5);
+        controller.printWorld(System.out);
+    }
+
+    @Test
+    public void testSpiralCritter()
+    {
+        Controller controller = ControllerFactory.getConsoleController();
+//        controller.newWorld();
+//        controller.loadCritters("src\\test\\resources\\A5files\\spiral_critter.txt", 1);
+        controller.loadWorld("src\\test\\resources\\A5files\\spiral_world.txt", false, false);
+        controller.printWorld(System.out);
+        System.out.println();
+        controller.advanceTime(300);
+        System.out.println();
+        controller.printWorld(System.out);
+    }
+
+    @Test
+    public void testEatCritter(){
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.loadWorld("src\\test\\resources\\A5files\\eat_world.txt", true, false);
+        controller.printWorld(System.out);
+        System.out.println();
+        controller.advanceTime(100);
+        System.out.println();
+        controller.printWorld(System.out);
+    }
+
+    @Test
+    public void testBudCritter(){
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.loadWorld("src\\test\\resources\\A5files\\bud_world.txt", false, false);
+        controller.printWorld(System.out);
+        System.out.println();
+        controller.advanceTime(10);
+        System.out.println();
+        controller.printWorld(System.out);
+    }
+
+    @Test
+    public void testSmeller(){
+        Controller controller = ControllerFactory.getConsoleController();
+        controller.loadWorld("src\\test\\resources\\A5files\\smell_world.txt", false, false);
+        controller.printWorld(System.out);
+        System.out.println();
+        controller.advanceTime(10);
+        System.out.println();
+        controller.printWorld(System.out);
+    }
+}
diff --git a/src/test/java/controller/DeterministicHexInformation.java b/src/test/java/controller/DeterministicHexInformation.java
new file mode 100644
index 0000000..22c0e9f
--- /dev/null
+++ b/src/test/java/controller/DeterministicHexInformation.java
@@ -0,0 +1,172 @@
+package controller;
+
+import model.ReadOnlyWorld;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Sealed class that records the hex information that is guaranteed to be deterministic.
+ */
+public abstract class DeterministicHexInformation {
+    private DeterministicHexInformation() {}
+
+    public static final class NonCritterHex extends DeterministicHexInformation {
+        public static final DeterministicHexInformation ROCK_HEX = new NonCritterHex(-1);
+        public static final DeterministicHexInformation EMPTY_HEX = new NonCritterHex(0);
+
+        public final int hexValue;
+
+        public NonCritterHex(int hexValue) {
+            this.hexValue = hexValue;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            NonCritterHex that = (NonCritterHex) o;
+            return hexValue == that.hexValue;
+        }
+
+        @Override
+        public int hashCode() {
+            return Integer.hashCode(hexValue);
+        }
+
+        @Override
+        public String toString() {
+            return "NonCritterHex{ hexValue=" + hexValue + " }";
+        }
+    }
+
+    public static final class CritterHex extends DeterministicHexInformation {
+        public final int memorySize;
+        public final int defense;
+        public final int offense;
+        public final int size;
+        public final int energy;
+        public final int posture;
+        public final List<Integer> otherMemorySlots;
+
+        public CritterHex(
+                int memorySize,
+                int defense,
+                int offense,
+                int size,
+                int energy,
+                int posture,
+                List<Integer> otherMemorySlots) {
+            this.memorySize = memorySize;
+            this.defense = defense;
+            this.offense = offense;
+            this.size = size;
+            this.energy = energy;
+            this.posture = posture;
+            this.otherMemorySlots = otherMemorySlots;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            CritterHex that = (CritterHex) o;
+            return memorySize == that.memorySize &&
+                    defense == that.defense &&
+                    offense == that.offense &&
+                    size == that.size &&
+                    energy == that.energy &&
+                    posture == that.posture &&
+                    otherMemorySlots.equals(that.otherMemorySlots);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(memorySize, defense, offense, size, energy, posture, otherMemorySlots);
+        }
+
+        @Override
+        public String toString() {
+            return String.format(
+                    "CritterHex{memorySize=%d, defense=%d, offense=%d, size=%d, energy=%d, posture=%d, otherMemorySlots=%s}",
+                    memorySize,
+                    defense,
+                    offense,
+                    size,
+                    energy,
+                    posture,
+                    otherMemorySlots);
+        }
+
+        static Builder builderWithEnergy(int energy) {
+            return new Builder(energy);
+        }
+
+        /**
+         * Use this builder so that we don't have to supply some default values every time.
+         */
+        public static final class Builder {
+            private int memorySize = 7;
+            private int defense = 1;
+            private int offense = 1;
+            private int size = 1;
+            private final int energy;
+            private int posture = 0;
+            private List<Integer> otherMemorySlots = List.of();
+
+            private Builder(int energy) {
+                this.energy = energy;
+            }
+
+            public Builder setMemorySize(int memorySize) {
+                this.memorySize = memorySize;
+                return this;
+            }
+
+            public Builder setDefense(int defense) {
+                this.defense = defense;
+                return this;
+            }
+
+            public Builder setOffense(int offense) {
+                this.offense = offense;
+                return this;
+            }
+
+            public Builder setSize(int size) {
+                this.size = size;
+                return this;
+            }
+
+            public Builder setPosture(int posture) {
+                this.posture = posture;
+                return this;
+            }
+
+            public Builder setOtherMemorySlots(List<Integer> otherMemorySlots) {
+                this.otherMemorySlots = otherMemorySlots;
+                return this;
+            }
+
+            public CritterHex build() {
+                return new CritterHex(memorySize, defense, offense, size, energy, posture, otherMemorySlots);
+            }
+        }
+    }
+
+    public static DeterministicHexInformation fromWorldLocation(ReadOnlyWorld world, int column, int row) {
+        return world.getReadOnlyCritter(column, row).<DeterministicHexInformation>then(critter -> {
+            final var memory = critter.getMemory();
+            List<Integer> otherMemorySlots = new ArrayList<>();
+            for (int i = 7; i < memory.length; i++) {
+                otherMemorySlots.add(memory[i]);
+            }
+            return new CritterHex(memory[0], memory[1], memory[2], memory[3], memory[4], memory[6], otherMemorySlots);
+        }).orElseGet(() -> new NonCritterHex(world.getTerrainInfo(column, row)));
+    }
+
+    public static DeterministicHexInformation foodHex(int amount) {
+        return new NonCritterHex(-1 - amount);
+    }
+}
diff --git a/src/test/java/parser/ParserTest.java b/src/test/java/parser/ParserTest.java
index 05abb5d..8219323 100644
--- a/src/test/java/parser/ParserTest.java
+++ b/src/test/java/parser/ParserTest.java
@@ -22,17 +22,18 @@ public class ParserTest
     @Test
     public void testProgramIsNotNone()
     {
-        InputStream in = ClassLoader.getSystemResourceAsStream("files/draw_critter_2.txt");
+        InputStream in = ClassLoader.getSystemResourceAsStream("files/draw_critter_5.txt");
         Reader r = new BufferedReader(new InputStreamReader(in));
         Parser parser = ParserFactory.getParser();
 
         try
         {
             Program prog = parser.parse(r);
-            System.out.println(prog.toString());
+            System.out.println(prog);
         }
         catch(SyntaxError e)
         {
+            System.out.println(e);
             fail("A valid program should not have syntax errors");
         }
     }
@@ -201,7 +202,7 @@ public class ParserTest
         try
         {
             Program prog = parser.parse(r);
-            Node target = prog.nodeAt((int) (Math.random() * prog.size()));;
+            Node target = prog.nodeAt((int) (Math.random() * prog.size()));
             while (!(mut.canApply(target)))
             {
                 target = prog.nodeAt((int) (Math.random() * prog.size()));
@@ -247,4 +248,77 @@ public class ParserTest
             fail("A valid program should not have syntax errors");
         }
     }
+
+    @Test
+    public void testBigRandom() throws SyntaxError
+    {
+        InputStream in = ClassLoader.getSystemResourceAsStream("files/draw_critter_2.txt");
+        Reader r = new BufferedReader(new InputStreamReader(in));
+        Parser parser = ParserFactory.getParser();
+        Program prog = parser.parse(r);
+//        Mutation mut = MutationFactory.getSwap();
+        Node target = prog.nodeAt((int) (Math.random() * prog.size()));
+        for (int i = 0; i < 1000; i++)
+        {
+            target = prog.nodeAt((int) (Math.random() * prog.size()));
+            System.out.println(i);
+            Mutation mut;
+            int mutationPicker = (int) (Math.random() * 6);
+            if (mutationPicker == 0)
+            {
+                mut = MutationFactory.getRemove();
+            }
+            else if (mutationPicker == 1)
+            {
+                mut = MutationFactory.getSwap();
+            }
+            else if (mutationPicker == 2)
+            {
+                mut = MutationFactory.getReplace();
+            }
+            else if (mutationPicker == 3)
+            {
+                mut = MutationFactory.getTransform();
+            }
+            else if (mutationPicker == 4)
+            {
+                mut = MutationFactory.getInsert();
+            }
+            else
+            {
+                mut = MutationFactory.getDuplicate();
+            }
+
+            int count = 0;
+            while (!(mut.canApply(target)) && count < 50)
+            {
+                target = prog.nodeAt((int) (Math.random() * prog.size()));
+                count++;
+            }
+            try
+            {
+                mut.apply(prog, target);
+//                System.out.println(mut.canApply(target));
+            }
+            catch (IndexOutOfBoundsException | StackOverflowError | NullPointerException e)
+            {
+                System.out.println(e);
+                System.out.println();
+                System.out.println(prog);
+                System.out.println();
+                System.out.println(mut.getClass());
+                System.out.println();
+                System.out.println(target);
+                System.out.println();
+                throw e;
+            }
+        }
+        System.out.println();
+        System.out.println(prog);
+        System.out.println();
+        System.out.println(target);
+        System.out.println();
+        System.out.println(target.getClass());
+    }
 }
+
diff --git a/src/test/resources/A5files/big_world.txt b/src/test/resources/A5files/big_world.txt
new file mode 100644
index 0000000..41825f7
--- /dev/null
+++ b/src/test/resources/A5files/big_world.txt
@@ -0,0 +1,11 @@
+name big world
+size 50 87
+
+critter bud_critter.txt 5 5 0
+critter kyle_critter.txt 10 12 1
+critter mate_critter.txt 32 4 1
+critter spiral_critter.txt 35 67 5
+critter spiral_critter.txt 48 85 2
+critter eat_critter.txt 3 55 0
+critter kyle_critter.txt 0 0 0
+critter run_critter.txt 25 20 4
\ No newline at end of file
diff --git a/src/test/resources/A5files/bud_critter.txt b/src/test/resources/A5files/bud_critter.txt
new file mode 100644
index 0000000..7514756
--- /dev/null
+++ b/src/test/resources/A5files/bud_critter.txt
@@ -0,0 +1,12 @@
+species: bud critter
+memsize: 8
+defense: 1
+offense: 1
+size: 5
+energy: 2500
+posture: 0
+
+nearby[3] = 0 and ENERGY >= 500 --> bud;
+ahead[1] = 0 --> serve[100];
+nearby[3] != 0 --> right;
+1 = 1 --> wait;
\ No newline at end of file
diff --git a/src/test/resources/A5files/bud_world.txt b/src/test/resources/A5files/bud_world.txt
new file mode 100644
index 0000000..2b918b1
--- /dev/null
+++ b/src/test/resources/A5files/bud_world.txt
@@ -0,0 +1,4 @@
+name eat world
+size 10 10
+
+critter bud_critter.txt 5 5 0
diff --git a/src/test/resources/A5files/eat_critter.txt b/src/test/resources/A5files/eat_critter.txt
new file mode 100644
index 0000000..e55fe2f
--- /dev/null
+++ b/src/test/resources/A5files/eat_critter.txt
@@ -0,0 +1,10 @@
+species: eat critter
+memsize: 8
+defense: 1
+offense: 1
+
+size: 5
+energy: 500
+posture: 0
+ahead[1] < -1 --> eat;
+ahead[1] >= -1 --> right;
\ No newline at end of file
diff --git a/src/test/resources/A5files/eat_world.txt b/src/test/resources/A5files/eat_world.txt
new file mode 100644
index 0000000..8741cf6
--- /dev/null
+++ b/src/test/resources/A5files/eat_world.txt
@@ -0,0 +1,4 @@
+name eat world
+size 10 10
+
+critter eat_critter.txt 5 5 0
diff --git a/src/test/resources/A5files/empty.wld b/src/test/resources/A5files/empty.wld
new file mode 100644
index 0000000..1dfc3bb
--- /dev/null
+++ b/src/test/resources/A5files/empty.wld
@@ -0,0 +1,2 @@
+name empty
+size 10 10
diff --git a/src/test/resources/A5files/kyle_critter.txt b/src/test/resources/A5files/kyle_critter.txt
new file mode 100644
index 0000000..de4e787
--- /dev/null
+++ b/src/test/resources/A5files/kyle_critter.txt
@@ -0,0 +1,15 @@
+species: Kyle Wyatt
+memsize: 8
+defense: 5
+offense: 1
+// weight: 250
+// bc he is fat:
+size: 10
+energy: 2500
+posture: 0
+
+
+nearby[3] = 0 and ENERGY >= 500 --> bud;
+ahead[1] = 0 --> serve[100];
+nearby[3] != 0 --> right;
+1 = 1 --> wait;
\ No newline at end of file
diff --git a/src/test/resources/A5files/mate_critter.txt b/src/test/resources/A5files/mate_critter.txt
new file mode 100644
index 0000000..e17cd67
--- /dev/null
+++ b/src/test/resources/A5files/mate_critter.txt
@@ -0,0 +1,11 @@
+species: mate critter
+memsize: 7
+defense: 1
+offense: 1
+size: 1
+energy: 2500
+posture: 0
+ahead[1] > 0 --> mate;
+ahead[1] = 0 --> forward;
+ahead[1] < 1 --> right;
+1 = 1 --> wait;
diff --git a/src/test/resources/A5files/run_critter.txt b/src/test/resources/A5files/run_critter.txt
new file mode 100644
index 0000000..e4cabb5
--- /dev/null
+++ b/src/test/resources/A5files/run_critter.txt
@@ -0,0 +1,11 @@
+species: run critter
+memsize: 8
+defense: 1
+offense: 1
+size: 2
+energy: 2500
+posture: 0
+
+nearby[0] = 0 --> forward;
+nearby[0] < -1 --> eat;
+nearby[0] = -1 or nearby[0] > 0 --> left;
\ No newline at end of file
diff --git a/src/test/resources/A5files/sit_critter.txt b/src/test/resources/A5files/sit_critter.txt
new file mode 100644
index 0000000..f218b96
--- /dev/null
+++ b/src/test/resources/A5files/sit_critter.txt
@@ -0,0 +1,13 @@
+species: written 3
+memsize: 7
+defense: 1
+offense: 1
+size: 5
+energy: 2500
+posture: 0
+mem[6] = 0 and smell < 1006 --> mem[6] := SMELL - 1000 + 2;
+mem[6] > 2 --> mem[6] := mem[6] - 1 right;
+mem[6] = 2 --> mem[6] := 1 eat;
+mem[6] = 1 --> mem[6] := 0 forward
+ENERGY >= 500 * SIZE - 100 --> bud;
+1 = 1 wait;
\ No newline at end of file
diff --git a/src/test/resources/A5files/small_world.txt b/src/test/resources/A5files/small_world.txt
new file mode 100644
index 0000000..77a4f7e
--- /dev/null
+++ b/src/test/resources/A5files/small_world.txt
@@ -0,0 +1,2 @@
+name Small
+size 1 1
diff --git a/src/test/resources/A5files/smell_critter.txt b/src/test/resources/A5files/smell_critter.txt
new file mode 100644
index 0000000..0f9cdfa
--- /dev/null
+++ b/src/test/resources/A5files/smell_critter.txt
@@ -0,0 +1,9 @@
+species: smell critter
+memsize: 8
+defense: 1
+offense: 1
+size: 5
+energy: 2500
+posture: 0
+
+smell > 1000 --> wait;
\ No newline at end of file
diff --git a/src/test/resources/A5files/smell_world.txt b/src/test/resources/A5files/smell_world.txt
new file mode 100644
index 0000000..187f3ed
--- /dev/null
+++ b/src/test/resources/A5files/smell_world.txt
@@ -0,0 +1,6 @@
+name smell world
+size 50 50
+
+critter smell_critter.txt 49 23 0
+
+
diff --git a/src/test/resources/A5files/space_critter.txt b/src/test/resources/A5files/space_critter.txt
new file mode 100644
index 0000000..b23b112
--- /dev/null
+++ b/src/test/resources/A5files/space_critter.txt
@@ -0,0 +1,8 @@
+species: space critter
+memsize: 7
+defense: 1
+offense: 1
+size: 1
+energy: 500
+posture: 0
+1 = 1 --> wait;
diff --git a/src/test/resources/A5files/space_world.txt b/src/test/resources/A5files/space_world.txt
new file mode 100644
index 0000000..b9a4161
--- /dev/null
+++ b/src/test/resources/A5files/space_world.txt
@@ -0,0 +1,3 @@
+name space world
+size 1 1
+critter space_critter.txt 0 0 0
diff --git a/src/test/resources/A5files/spiral_critter.txt b/src/test/resources/A5files/spiral_critter.txt
new file mode 100644
index 0000000..27e3cad
--- /dev/null
+++ b/src/test/resources/A5files/spiral_critter.txt
@@ -0,0 +1,14 @@
+species: written 3
+memsize: 11
+defense: 1
+offense: 1
+size: 5
+energy: 2500
+posture: 0
+mem[7] = 0 --> mem[7] := 1 mem[8] := mem[7] * 6 mem[9] := 1 mem[10] := 0 forward;
+mem[6] < 1 --> mem[6] := mem[6] + 1 right;
+mem[8] > 1 and mem[10] = 0 --> mem[10] := mem[9] right;
+nearby[0] = 0 and mem[8] > 1 and mem[10] > 0 --> mem[8] := mem[8] - 1 mem[10] := mem[10] - 1 forward;
+nearby[0] = 0 and mem[8] = 1 --> mem[6] := 0 mem[7] := mem[7] + 1 mem[8] := mem[7] * 6 mem[9] := mem[9] + 1 mem[10] := mem[9] + 1 forward;
+nearby[0] < -1 --> eat;
+nearby[0] = -1 --> right;
diff --git a/src/test/resources/A5files/spiral_world.txt b/src/test/resources/A5files/spiral_world.txt
new file mode 100644
index 0000000..20611e2
--- /dev/null
+++ b/src/test/resources/A5files/spiral_world.txt
@@ -0,0 +1,4 @@
+name test world
+size 50 50
+
+critter spiral_critter.txt 25 25 0
\ No newline at end of file
diff --git a/src/test/resources/A5files/test_critter.txt b/src/test/resources/A5files/test_critter.txt
new file mode 100644
index 0000000..c0d1916
--- /dev/null
+++ b/src/test/resources/A5files/test_critter.txt
@@ -0,0 +1,17 @@
+species: test critter
+memsize: 8
+defense: 1
+offense: 1
+
+size: 5
+energy: 2500
+posture: 0
+// test
+//POSTURE != 17 --> POSTURE := 17;
+ahead[0] > 0 and ENERGY > 2400 --> mate;
+ahead[0] = 0 --> forward;
+//{nearby[3] = 0 and ENERGY > 2500} --> bud;
+//{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
+//ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
+//(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
+1 = 1 --> wait;
\ No newline at end of file
diff --git a/src/test/resources/A5files/test_world.txt b/src/test/resources/A5files/test_world.txt
new file mode 100644
index 0000000..1f93d4a
--- /dev/null
+++ b/src/test/resources/A5files/test_world.txt
@@ -0,0 +1,7 @@
+name test world
+size 18 21
+// test
+
+critter space_critter.txt 0 0 0
+critter test_critter.txt 2 4 1
+critter test_critter.txt 3 5 4
\ No newline at end of file
diff --git a/src/test/resources/files/draw_critter_3.txt b/src/test/resources/files/draw_critter_3.txt
new file mode 100644
index 0000000..0cc0bc8
--- /dev/null
+++ b/src/test/resources/files/draw_critter_3.txt
@@ -0,0 +1,9 @@
+3 > ahead[-1] - (mem[-7] + 6) --> mem[6] := mem[mem[4]] mem[mem[mem[-1]]] := -1 mem[6] := 6 mem[6] := 6 mem[2] := 17 mem[6] := mem[-6] mem[mem[2]] := -1 mem[6] := 6;
+3 != mem[6] / mem[3] and 2 != -1 --> mem[6] := 3 mem[-1] := 17 mem[17] := 17 mem[6] := 18 mem[6] := 6 mem[mem[mem[mem[mem[mem[mem[mem[6]]]]]]]] := mem[4] mem[mem[mem[mem[6]]]] := mem[4] mem[2] := 2;
+mem[6] > 17 and {-1 < 3 or 1 < 17} --> mem[-1] := 3 mem[2] := 2 mem[11] := 17 mem[2] := 3 mem[1] := mem[4] mem[2500] := 17 mem[-2] := 13 mem[mem[mem[mem[mem[mem[mem[6]]]]]]] := mem[4] mem[mem[2]] := 1 mem[2] := mem[mem[mem[17]]] mem[2] := mem[mem[mem[17]]] mem[6] := 6 bud;
+mem[3] > 2500 and 3 < -1 and -1 - 2500 < 3 and mem[3] / 2500 * 2 + 6 >= 4 and -1 * 2500 < 3 and {2 * (mem[3] / mem[1] mod (2 * mem[6] + 6)) + 6 >= 4 or 17 > 6 and 2500 >= mem[mem[3]]} and mem[2] > 2500 --> mem[4] := mem[3] mem[mem[mem[mem[mem[6 + 3 mod (mem[6] mod mem[-1])]]]]] := 4 mem[6] := 17 mem[mem[-5]] := 3 mem[mem[2]] := -1 mem[mem[-1]] := mem[-1] bud;
+3 * mem[mem[2]] > 7 + (mem[3] - -1) - ahead[1] and {-5 < 1 and 17 > mem[6] and 2500 >= mem[mem[3]] and mem[6] < mem[-13] * -1 and mem[4] >= 2 * (mem[3] / mem[6]) + 6 and 3 / 7 < -1 or mem[6] > 17} --> mem[2] := 18 mem[mem[mem[-1]]] := -6 mem[6] := 6 mem[mem[mem[mem[mem[mem[mem[mem[6]]]]]]]] := mem[4] mem[17] := 17 mate;
+4 = 7 or 2500 > mem[-1] and nearby[3] = 7 or 2 - 7 = nearby[3] or -1 < 3 and mem[17] - 1 * -1 + 6 >= 6 or 2 * (mem[3] / 2500 / 17) + 6 mod 4 >= 4 --> mem[mem[mem[-4]]] := 4 mem[-1] := mem[2] mem[mem[6]] := 4 mem[2] := 17 mem[-1] := -6 bud;
+4 = mem[6] or {1 = 7 - mem[6] or -1 < 3 and 3 / 3 < -1 and mem[4] >= mem[3] / mem[6] * 2 + 6 and mem[4] >= 6 mod -1 * mem[6] and 6 + 45 mod mem[mem[mem[6]]] * (mem[6] - 2) >= mem[mem[1]]} and nearby[3] = 7 --> mem[6] := 6 mem[6] := 17 mem[6] := 4 mem[mem[mem[2]]] := 17 mem[6] := 6 mem[mem[-12]] := -7 mem[2] := 17 mem[mem[6]] := 6 mem[6] := 17 mem[mem[mem[mem[2]]]] := 17 mem[-1] := -6 mem[17] := 17;
+mem[2] * 3 > mem[2] - (mem[3] - -1 + 7) and {7 < 1 and 2500 >= mem[-1] and mem[mem[3]] > mem[6] and 7 < 1 and 7 mod -17 > mem[6] and 7 >= 3 and {3 > 6 - mem[-1] or nearby[3] = 7} and 3 >= 3 or {7 < 1 and -7 >= mem[mem[mem[6 - mem[-2]]]] and 17 > mem[6] or 4 >= 6 mod mem[mem[-6]] + 6 * 6} and 1 < mem[6] and 3 / 3 <= -1 and mem[4] >= 2 * (3 / mem[6]) + 6} --> mem[2] := -6 mem[-1] := -6 mem[6] := 3 * mem[mem[2]] mem[mem[mem[mem[mem[mem[3] / mem[6]]]]]] := mem[4] mem[-1] := -6 mem[mem[mem[mem[6]]]] := mem[4] mem[6] := 6 mem[6] := 4 mate;
+(6 + 6) / mem[3] != 3 and 2 != -1 --> mem[mem[mem[mem[mem[mem[6]]]]]] := mem[4] mem[-1] := 17 mem[17] := 17 mem[6] := 4 mem[2] := 2 mem[2] := mem[mem[mem[17]]] mem[mem[mem[mem[mem[6]]]]] := mem[4] mem[mem[6]] := mem[6];
\ No newline at end of file
diff --git a/src/test/resources/files/draw_critter_4.txt b/src/test/resources/files/draw_critter_4.txt
new file mode 100644
index 0000000..049137d
--- /dev/null
+++ b/src/test/resources/files/draw_critter_4.txt
@@ -0,0 +1,13 @@
+mem[mem[17]] != mem[mem[6]] and mem[mem[-1]] != mem[6] and mem[4] >= 17 - -1 --> mem[-3] := -113 mem[mem[-3]] := mem[-13] mem[mem[mem[-1]]] := mem[mem[mem[mem[6]]]] mem[mem[-1]] := mem[-2] mem[6] := -14 mem[mem[mem[mem[mem[mem[mem[1]]]]]]] := mem[mem[5]] mem[mem[-6]] := -6 mem[1] := -1 / (17 / (17 * -1)) mem[-1] := 17 * -1 eat;
+mem[mem[-1]] != mem[6] and 17 * -1 * 1 > mem[mem[4]] --> mem[6] := -1 mem[-3] := 3 mem[mem[mem[1]]] := mem[mem[mem[17]]] mem[mem[mem[-1]]] := mem[mem[17]] mem[-1] := mem[mem[mem[5]]] mem[-6] := -6 mem[-1] := -1 * -1 mem[-1] := 6 mem[mem[mem[-1]]] := 17 * -1 mem[-1] := mem[1] mem[mem[mem[-1]]] := 17 * -1 mem[mem[mem[-1]]] := mem[mem[mem[1]]] mem[4] := 16 eat;
+17 / -1 != mem[3] --> mem[mem[mem[mem[mem[mem[6]]]]]] := mem[1] mem[-1] := -1 mem[2] := 2 mem[-2] := -2 mem[-1] := mem[mem[mem[mem[17]]]] mem[mem[mem[mem[17]]]] := mem[mem[-2]] mem[mem[mem[-6]]] := -6 mem[-1] := mem[56] mem[-3] := -3 mem[mem[-3]] := mem[mem[mem[1]]] mem[-1] := mem[mem[mem[1]]] forward;
+-1 = 6 --> mem[mem[-1]] := mem[56] mem[1] := 1 mem[-1] := mem[mem[mem[mem[mem[mem[mem[84]]]]]]] mem[-1] := 17 mem[mem[-3]] := 1 mem[mem[mem[6]]] := mem[mem[6]] mem[6] := mem[6] mem[-1] := -1 mem[mem[1]] := mem[mem[1]] mem[-1] := 17 eat;
+1 = -1 --> mem[6] := mem[mem[mem[4]]] mem[mem[mem[mem[1]]]] := mem[2] mem[1] := mem[3] mem[-1] := mem[1] mem[-1] := 17 mem[-1] := mem[-1] mem[mem[mem[6]]] := -14 mem[-1] := mem[mem[mem[17]]] mem[-1] := 17 mem[56] := -1 mem[mem[2]] := 4 mem[mem[6]] := mem[mem[mem[mem[mem[-1]]]]] mem[-1] := 17 mem[-1] := mem[mem[-1]] mem[-1] := 17 mem[-1] := -9;
+mem[-1] * mem[mem[mem[6]]] != 2 --> mem[-3] := -3 mem[-1] := mem[56] mem[-1] := -9 mem[-1] := 6 mem[1] := mem[mem[mem[-5]]] mem[mem[mem[6]]] := 6 mem[-1] := -1;
+6 < -1 --> mem[4] := -6 mem[mem[mem[mem[mem[mem[mem[1]]]]]]] := mem[mem[6]] mem[mem[mem[-3]]] := 1 mem[-1] := mem[mem[mem[1]]] mem[mem[mem[4]]] := mem[mem[mem[-41]]] mem[6] := mem[6] mem[-1] := -1 mem[mem[mem[mem[6]]]] := mem[mem[mem[1]]] mem[mem[mem[17]]] := mem[6] mem[-1] := mem[mem[5]] mem[-3] := 1 mem[-1] := mem[56] mem[-1] := mem[mem[17]] mem[6] := -1;
+1 = -1 --> mem[6] := mem[mem[mem[mem[4]]]] mem[mem[mem[mem[1]]]] := 6 mem[1] := mem[3] mem[-1] := mem[1] mem[-1] := 17 mem[-1] := -1 mem[mem[mem[6]]] := -14 mem[-1] := mem[mem[mem[17]]] mem[-1] := 17 mem[mem[-1]] := 17 * -1 mem[mem[2]] := 4 mem[mem[6]] := mem[mem[mem[mem[mem[-1]]]]] mem[-3] := -3 mem[-1] := mem[mem[mem[mem[mem[1]]]]] mem[-1] := mem[-1];
+mem[17] mod mem[mem[mem[6]]] != 2 --> mem[6] := mem[6] mem[mem[mem[6]]] := mem[3] mem[-3] := 1 mem[6] := mem[mem[mem[6]]] mem[-1] := mem[mem[5]] mem[6] := mem[mem[6]];
+17 * -1 != mem[-1] and mem[mem[3]] != (mem[1] - -1) * 17 --> mem[6] := 6 mem[6] := mem[mem[mem[6]]] mem[mem[56]] := 56 mem[6] := mem[mem[mem[mem[6]]]] mem[-1] := mem[mem[mem[2]]] mem[-1] := mem[mem[mem[-1]]] mem[mem[-3]] := mem[mem[1]] mem[-1] := -1 mem[5] := -6 mem[mem[mem[-1]]] := mem[mem[mem[mem[6]]]];
+mem[mem[17 * -1]] != 17 / -1 --> mem[mem[mem[mem[1]]]] := mem[mem[mem[-7]]] mem[-1] := 1 mem[-1] := mem[mem[5]] mem[-1] := mem[mem[mem[mem[mem[mem[mem[-1]]]]]]] mem[6] := -14 mem[1] := -6 mem[mem[-1]] := 17 mem[6] := 6 mem[-1] := mem[14 * -1] mem[mem[mem[-1]]] := mem[mem[mem[1]]] mem[mem[6]] := -14 mem[mem[mem[mem[6]]]] := mem[mem[mem[1]]] mem[-3] := mem[3] mem[-1] := -9 mem[-1] := 17 eat;
+17 * 6 != mem[mem[4]] and -1 * 17 != mem[-1] --> mem[-6] := -6 mem[mem[mem[mem[-1]]]] := mem[-1] mem[mem[-1]] := mem[mem[mem[56]]] mem[56] := 56 mem[mem[1]] := 1 mem[mem[-1]] := -1 mem[-1] := mem[mem[5]] mem[mem[-1]] := mem[mem[mem[mem[1]]]] mem[-1] := -1 mem[1] := 6 mem[mem[mem[17]]] := mem[mem[6]] mem[mem[mem[17]]] := mem[6] mem[mem[mem[6]]] := -14 attack;
+mem[17] mod mem[mem[mem[6]]] != 2 --> mem[6] := mem[6] mem[mem[mem[6]]] := mem[3] mem[-3] := 1 mem[6] := mem[mem[mem[6]]] mem[-1] := mem[mem[5]] mem[6] := mem[mem[6]];
\ No newline at end of file
diff --git a/src/test/resources/files/draw_critter_5.txt b/src/test/resources/files/draw_critter_5.txt
new file mode 100644
index 0000000..9ccbf3e
--- /dev/null
+++ b/src/test/resources/files/draw_critter_5.txt
@@ -0,0 +1,12 @@
+ahead[6] < -1 mod mem[1] mod mem[1] --> mem[-1] := mem[-1] mem[1] := 1 mem[mem[-1]] := mem[3] mem[4] := 4 mem[6] := -1 mem[4] := 4 mem[mem[3]] := 2 bud;
+6 = 1 * 17 and {-1 != -3 or 4 < 2 / 3 or -1 < mem[mem[mem[mem[1]]]]} and -1 mod mem[1] < ahead[6] --> mem[mem[1]] := 3 mem[mem[1]] := mem[1] mem[mem[2]] := 1 mem[1] := mem[mem[-9]] mem[1] := 1 mem[6] := 17 mem[-1] := ahead[6] mem[6] := 4 mem[6] := 6 mem[1] := mem[mem[1]] mem[mem[-2]] := 2;
+4 != 1 and 6 < 1 mod mem[1] --> mem[mem[3]] := -8 mem[mem[6]] := 6 mem[mem[3]] := 1 mem[6] := 17 mem[6] := 6 mem[mem[mem[6]]] := 2 mem[mem[2]] := 6 mem[6] := -3 mem[6] := mem[1] mem[6] := 1 mem[mem[1]] := mem[6] mem[1] := mem[-23] mem[1] := mem[mem[1]] mem[mem[1]] := 6 left;
+6 < mem[1] mod 1 --> mem[mem[3]] := -8 mem[mem[6]] := 6 mem[mem[3]] := 1 mem[6] := 6 mem[6] := 6 mem[mem[6]] := 2 mem[mem[2]] := 6 mem[6] := -3 mem[6] := mem[1] mem[6] := 1 mem[mem[1]] := mem[6] mem[1] := mem[-23] mem[1] := mem[mem[-9]] mem[mem[1]] := 6 mem[1] := mem[-9] mem[6] := 4 left;
+4 <= mem[3] / -3 --> mem[-1] := 0 mem[mem[1]] := -22 mem[3] := 6 mem[mem[3]] := mem[1 * -1] mem[-1] := -1 mem[mem[3]] := mem[-1] mem[6] := mem[1] mem[1 + (-1 + 1 mod (mem[1] / mem[-1]))] := -1 mem[1] := mem[-9] mem[1] := mem[mem[-9]] mem[mem[3]] := -8;
+(-1 + -1 / -1) * 1 - 6 <= mem[mem[mem[1]]] --> mem[2] := 2 mem[mem[mem[1] + (1 * 6 mod -95 - mem[-1])]] := -2 mem[-1] := 17 mem[1] := mem[6] mem[mem[-1]] := 17 mem[mem[1]] := mem[6] mem[6] := 6 mem[1] := mem[-2] mem[-1] := ahead[6] mem[1] := mem[-23] left;
+-1 * -1 / (-1 * mem[1] * ((3 - mem[1]) / ahead[2])) < mem[7] or 4 < -1 --> mem[1] := -1 mem[mem[2]] := 6 mem[-3] := 0 mem[mem[1]] := 6 mem[mem[-1]] := ahead[1] mem[6] := -3 mem[2] := 4 mem[6] := 6 mem[1] := 6 mem[-1] := ahead[1];
+mem[mem[1]] <= (-1 / -1 + -1) * 1 --> mem[-2] := 2 mem[2] := 2 mem[6] := 6 mem[-1] := 17 mem[-1] := mem[mem[6]] mem[mem[-1]] := 17 mem[mem[1]] := mem[6] mem[6] := 6 mem[17 + (-95 mod 1 - -1)] := -1 mem[-3] := -2 mem[mem[mem[3]]] := mem[-1] left;
+-3 != -1 or 6 < 3 / 2 or -3 < mem[mem[mem[mem[1]]]] --> mem[mem[1]] := 1 mem[500] := mem[3] mem[6] := 17 mem[mem[-31]] := mem[mem[6]] mem[6] := mem[mem[-1]] mem[mem[1]] := 6 mem[1] := 1 mem[6] := -1 left;
+ahead[6] < -1 mod 1 or -1 != -1 or {mem[mem[1]] != -1 + 1 mod mem[mem[mem[1]]] + 17 or -2 < ahead[-35] mod (mem[6] + 4) mod -3} and {-3 != -1 or 6 < 2 * mem[mem[1]] / 3} --> mem[-23] := mem[6] mem[mem[mem[3]]] := 2 mem[-1] := mem[mem[-1]] mem[6] := 17 mem[6] := -1 mem[3] := mem[6] mem[-1] := mem[1] mem[6] := mem[6] mem[mem[-3]] := 6 mem[-31] := 4 mem[-31] := mem[4] mem[1] := mem[mem[mem[1]]] mem[mem[1]] := mem[1] mem[-1] := 0 mem[2] := 2 mem[mem[1]] := 6 mem[1] := mem[mem[-9]] bud;
+4 >= ahead[-3] / mem[-1 - 1 + -1 * mem[1] / -9] --> mem[-1] := 0 mem[-1] := 6 mem[mem[3]] := mem[0] mem[-3] := -1 mem[mem[mem[3]]] := mem[-1] mem[mem[6]] := mem[(-1 + -1 / -1) * 3 - 6] mem[1 + (-1 + (1 mod (mem[1] / mem[-1]) + mem[6] + 4 mod ahead[-35] mod -3))] := -1 mem[mem[mem[-1]]] := 4 mem[1] := -9;
+mem[1] <= (3 / -1 + -1) * 1 --> mem[-2] := 2 mem[2] := 2 mem[mem[17 + (1 - -95 - -1)]] := mem[-1] mem[-1] := 17 mem[-1] := mem[mem[6]] mem[mem[-1]] := 17 mem[mem[1]] := mem[6] mem[6] := 6 mem[6] := 6 mem[1] := -2 mem[1] := mem[mem[-9]] left;
\ No newline at end of file
diff --git a/src/test/resources/files/mutated_critter_1.txt b/src/test/resources/files/mutated_critter_1.txt
index 1ceca44..9bd1c39 100644
--- a/src/test/resources/files/mutated_critter_1.txt
+++ b/src/test/resources/files/mutated_critter_1.txt
@@ -13,3 +13,4 @@ nearby[0] > 0 and nearby[3] = 0 --> backward;
 ahead[1] < -1 and { ENERGY > 2500 or SIZE > 7 } --> serve[ENERGY / 42];
 random[3] = 1 --> left;
 1 = 1 --> wait;
+// test
\ No newline at end of file
